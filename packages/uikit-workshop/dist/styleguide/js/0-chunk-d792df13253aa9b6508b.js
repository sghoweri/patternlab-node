(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "./node_modules/@webcomponents/shadydom/src/shadydom.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@webcomponents/shadydom/src/shadydom.js + 16 modules ***!
  \***************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("var native_methods_namespaceObject = {};\n__webpack_require__.r(native_methods_namespaceObject);\n__webpack_require__.d(native_methods_namespaceObject, \"appendChild\", function() { return native_methods_appendChild; });\n__webpack_require__.d(native_methods_namespaceObject, \"insertBefore\", function() { return native_methods_insertBefore; });\n__webpack_require__.d(native_methods_namespaceObject, \"replaceChild\", function() { return native_methods_replaceChild; });\n__webpack_require__.d(native_methods_namespaceObject, \"removeChild\", function() { return native_methods_removeChild; });\n__webpack_require__.d(native_methods_namespaceObject, \"setAttribute\", function() { return native_methods_setAttribute; });\n__webpack_require__.d(native_methods_namespaceObject, \"removeAttribute\", function() { return native_methods_removeAttribute; });\n__webpack_require__.d(native_methods_namespaceObject, \"cloneNode\", function() { return native_methods_cloneNode; });\n__webpack_require__.d(native_methods_namespaceObject, \"importNode\", function() { return native_methods_importNode; });\n__webpack_require__.d(native_methods_namespaceObject, \"addEventListener\", function() { return addEventListener; });\n__webpack_require__.d(native_methods_namespaceObject, \"removeEventListener\", function() { return removeEventListener; });\n__webpack_require__.d(native_methods_namespaceObject, \"windowAddEventListener\", function() { return windowAddEventListener; });\n__webpack_require__.d(native_methods_namespaceObject, \"windowRemoveEventListener\", function() { return windowRemoveEventListener; });\n__webpack_require__.d(native_methods_namespaceObject, \"dispatchEvent\", function() { return native_methods_dispatchEvent; });\n__webpack_require__.d(native_methods_namespaceObject, \"contains\", function() { return native_methods_contains; });\n__webpack_require__.d(native_methods_namespaceObject, \"getElementById\", function() { return native_methods_getElementById; });\n__webpack_require__.d(native_methods_namespaceObject, \"elementQuerySelector\", function() { return elementQuerySelector; });\n__webpack_require__.d(native_methods_namespaceObject, \"fragmentQuerySelector\", function() { return fragmentQuerySelector; });\n__webpack_require__.d(native_methods_namespaceObject, \"documentQuerySelector\", function() { return documentQuerySelector; });\n__webpack_require__.d(native_methods_namespaceObject, \"querySelector\", function() { return native_methods_querySelector; });\n__webpack_require__.d(native_methods_namespaceObject, \"elementQuerySelectorAll\", function() { return elementQuerySelectorAll; });\n__webpack_require__.d(native_methods_namespaceObject, \"fragmentQuerySelectorAll\", function() { return fragmentQuerySelectorAll; });\n__webpack_require__.d(native_methods_namespaceObject, \"documentQuerySelectorAll\", function() { return documentQuerySelectorAll; });\n__webpack_require__.d(native_methods_namespaceObject, \"querySelectorAll\", function() { return native_methods_querySelectorAll; });\nvar native_tree_walker_namespaceObject = {};\n__webpack_require__.r(native_tree_walker_namespaceObject);\n__webpack_require__.d(native_tree_walker_namespaceObject, \"parentNode\", function() { return parentNode; });\n__webpack_require__.d(native_tree_walker_namespaceObject, \"firstChild\", function() { return native_tree_walker_firstChild; });\n__webpack_require__.d(native_tree_walker_namespaceObject, \"lastChild\", function() { return lastChild; });\n__webpack_require__.d(native_tree_walker_namespaceObject, \"previousSibling\", function() { return previousSibling; });\n__webpack_require__.d(native_tree_walker_namespaceObject, \"nextSibling\", function() { return nextSibling; });\n__webpack_require__.d(native_tree_walker_namespaceObject, \"childNodes\", function() { return native_tree_walker_childNodes; });\n__webpack_require__.d(native_tree_walker_namespaceObject, \"parentElement\", function() { return parentElement; });\n__webpack_require__.d(native_tree_walker_namespaceObject, \"firstElementChild\", function() { return firstElementChild; });\n__webpack_require__.d(native_tree_walker_namespaceObject, \"lastElementChild\", function() { return lastElementChild; });\n__webpack_require__.d(native_tree_walker_namespaceObject, \"previousElementSibling\", function() { return previousElementSibling; });\n__webpack_require__.d(native_tree_walker_namespaceObject, \"nextElementSibling\", function() { return nextElementSibling; });\n__webpack_require__.d(native_tree_walker_namespaceObject, \"children\", function() { return native_tree_walker_children; });\n__webpack_require__.d(native_tree_walker_namespaceObject, \"innerHTML\", function() { return innerHTML; });\n__webpack_require__.d(native_tree_walker_namespaceObject, \"textContent\", function() { return textContent; });\nvar native_tree_accessors_namespaceObject = {};\n__webpack_require__.r(native_tree_accessors_namespaceObject);\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"nodeAccessors\", function() { return nodeAccessors; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"fragmentAccessors\", function() { return fragmentAccessors; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"documentAccessors\", function() { return documentAccessors; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"parentNode\", function() { return native_tree_accessors_parentNode; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"firstChild\", function() { return native_tree_accessors_firstChild; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"lastChild\", function() { return native_tree_accessors_lastChild; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"previousSibling\", function() { return native_tree_accessors_previousSibling; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"nextSibling\", function() { return native_tree_accessors_nextSibling; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"childNodes\", function() { return native_tree_accessors_childNodes; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"parentElement\", function() { return native_tree_accessors_parentElement; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"previousElementSibling\", function() { return native_tree_accessors_previousElementSibling; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"nextElementSibling\", function() { return native_tree_accessors_nextElementSibling; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"innerHTML\", function() { return native_tree_accessors_innerHTML; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"textContent\", function() { return native_tree_accessors_textContent; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"children\", function() { return native_tree_accessors_children; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"firstElementChild\", function() { return native_tree_accessors_firstElementChild; });\n__webpack_require__.d(native_tree_accessors_namespaceObject, \"lastElementChild\", function() { return native_tree_accessors_lastElementChild; });\n\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/shady-data.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nvar ShadyData =\n/*#__PURE__*/\nfunction () {\n  function ShadyData() {\n    _classCallCheck(this, ShadyData);\n\n    /** @type {ShadowRoot} */\n    this.root = null;\n    /** @type {ShadowRoot} */\n\n    this.publicRoot = null;\n    this.dirty = false;\n    this.observer = null;\n    /** @type {Array<Node>} */\n\n    this.assignedNodes = null;\n    /** @type {Element} */\n\n    this.assignedSlot = null;\n    /** @type {Array<Node>} */\n\n    this._previouslyAssignedNodes = null;\n    /** @type {Element} */\n\n    this._prevAssignedSlot = null;\n    /** @type {Array<Node>} */\n\n    this.flattenedNodes = null;\n    this.ownerShadyRoot = undefined;\n    /** @type {Node|undefined} */\n\n    this.parentNode = undefined;\n    /** @type {Node|undefined} */\n\n    this.firstChild = undefined;\n    /** @type {Node|undefined} */\n\n    this.lastChild = undefined;\n    /** @type {Node|undefined} */\n\n    this.previousSibling = undefined;\n    /** @type {Node|undefined} */\n\n    this.nextSibling = undefined;\n    /** @type {Array<Node>|undefined} */\n\n    this.childNodes = undefined;\n    this.__outsideAccessors = false;\n    this.__insideAccessors = false;\n    this.__onCallbackListeners = {};\n  }\n\n  _createClass(ShadyData, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {};\n    }\n  }]);\n\n  return ShadyData;\n}();\nfunction ensureShadyDataForNode(node) {\n  if (!node.__shady) {\n    node.__shady = new ShadyData();\n  }\n\n  return node.__shady;\n}\nfunction shadyDataForNode(node) {\n  return node && node.__shady;\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/utils.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nvar settings = window['ShadyDOM'] || {};\nsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\nvar desc = Object.getOwnPropertyDescriptor(Node.prototype, 'firstChild');\nsettings.hasDescriptors = Boolean(desc && desc.configurable && desc.get);\nsettings.inUse = settings['force'] || !settings.hasNativeShadowDOM; // Default to using native accessors (instead of treewalker) only for\n// IE/Edge where they are faster.\n\nvar IS_IE = navigator.userAgent.match('Trident');\nvar IS_EDGE = navigator.userAgent.match('Edge');\n\nif (settings.useNativeAccessors === undefined) {\n  settings.useNativeAccessors = settings.hasDescriptors && (IS_IE || IS_EDGE);\n}\n\nfunction isTrackingLogicalChildNodes(node) {\n  var nodeData = shadyDataForNode(node);\n  return nodeData && nodeData.firstChild !== undefined;\n}\nfunction utils_isShadyRoot(obj) {\n  return Boolean(obj._localName === 'ShadyRoot');\n}\nfunction ownerShadyRootForNode(node) {\n  var root = node.getRootNode();\n\n  if (utils_isShadyRoot(root)) {\n    return root;\n  }\n}\nvar utils_p = Element.prototype;\nvar matches = utils_p.matches || utils_p.matchesSelector || utils_p.mozMatchesSelector || utils_p.msMatchesSelector || utils_p.oMatchesSelector || utils_p.webkitMatchesSelector;\nfunction matchesSelector(element, selector) {\n  return matches.call(element, selector);\n}\n\nfunction copyOwnProperty(name, source, target) {\n  var pd = Object.getOwnPropertyDescriptor(source, name);\n\n  if (pd) {\n    Object.defineProperty(target, name, pd);\n  }\n}\n\nfunction extend(target, source) {\n  if (target && source) {\n    var n$ = Object.getOwnPropertyNames(source);\n\n    for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {\n      copyOwnProperty(n, source, target);\n    }\n  }\n\n  return target || source;\n}\nfunction extendAll(target) {\n  for (var i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); i++) {\n    extend(target, i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1]);\n  }\n\n  return target;\n}\nfunction mixin(target, source) {\n  for (var i in source) {\n    target[i] = source[i];\n  }\n\n  return target;\n}\nfunction patchPrototype(obj, mixin) {\n  var proto = Object.getPrototypeOf(obj);\n\n  if (!proto.hasOwnProperty('__patchProto')) {\n    var patchProto = Object.create(proto);\n    patchProto.__sourceProto = proto;\n    extend(patchProto, mixin);\n    proto['__patchProto'] = patchProto;\n  } // old browsers don't have setPrototypeOf\n\n\n  obj.__proto__ = proto['__patchProto'];\n}\nvar twiddle = document.createTextNode('');\nvar utils_content = 0;\nvar queue = [];\nnew MutationObserver(function () {\n  while (queue.length) {\n    // catch errors in user code...\n    try {\n      queue.shift()();\n    } catch (e) {\n      // enqueue another record and throw\n      twiddle.textContent = utils_content++;\n      throw e;\n    }\n  }\n}).observe(twiddle, {\n  characterData: true\n}); // use MutationObserver to get microtask async timing.\n\nfunction microtask(callback) {\n  queue.push(callback);\n  twiddle.textContent = utils_content++;\n}\nvar hasDocumentContains = Boolean(document.contains);\nfunction utils_contains(container, node) {\n  while (node) {\n    if (node == container) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n}\n\nfunction getNodeHTMLCollectionName(node) {\n  return node.getAttribute('id') || node.getAttribute('name');\n}\n\nfunction isValidHTMLCollectionName(name) {\n  return name !== 'length' && isNaN(name);\n}\n\nfunction createPolyfilledHTMLCollection(nodes) {\n  // Note: loop in reverse so that the first named item matches the named property\n  for (var l = nodes.length - 1; l >= 0; l--) {\n    var node = nodes[l];\n    var name = getNodeHTMLCollectionName(node);\n\n    if (name && isValidHTMLCollectionName(name)) {\n      nodes[name] = node;\n    }\n  }\n\n  nodes.item = function (index) {\n    return nodes[index];\n  };\n\n  nodes.namedItem = function (name) {\n    if (isValidHTMLCollectionName(name) && nodes[name]) {\n      return nodes[name];\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _node = _step.value;\n        var nodeName = getNodeHTMLCollectionName(_node);\n\n        if (nodeName == name) {\n          return _node;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  return nodes;\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/flush.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n // render enqueuer/flusher\n\nvar flushList = [];\nvar scheduled;\nfunction enqueue(callback) {\n  if (!scheduled) {\n    scheduled = true;\n    microtask(flush);\n  }\n\n  flushList.push(callback);\n}\nfunction flush() {\n  scheduled = false;\n  var didFlush = Boolean(flushList.length);\n\n  while (flushList.length) {\n    flushList.shift()();\n  }\n\n  return didFlush;\n}\nflush['list'] = flushList;\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/observe-changes.js\nfunction observe_changes_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction observe_changes_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction observe_changes_createClass(Constructor, protoProps, staticProps) { if (protoProps) observe_changes_defineProperties(Constructor.prototype, protoProps); if (staticProps) observe_changes_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar observe_changes_AsyncObserver =\n/*#__PURE__*/\nfunction () {\n  function AsyncObserver() {\n    observe_changes_classCallCheck(this, AsyncObserver);\n\n    this._scheduled = false;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.callbacks = new Set();\n  }\n\n  observe_changes_createClass(AsyncObserver, [{\n    key: \"schedule\",\n    value: function schedule() {\n      var _this = this;\n\n      if (!this._scheduled) {\n        this._scheduled = true;\n        microtask(function () {\n          _this.flush();\n        });\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this._scheduled) {\n        this._scheduled = false;\n        var mutations = this.takeRecords();\n\n        if (mutations.length) {\n          this.callbacks.forEach(function (cb) {\n            cb(mutations);\n          });\n        }\n      }\n    }\n  }, {\n    key: \"takeRecords\",\n    value: function takeRecords() {\n      if (this.addedNodes.length || this.removedNodes.length) {\n        var mutations = [{\n          addedNodes: this.addedNodes,\n          removedNodes: this.removedNodes\n        }];\n        this.addedNodes = [];\n        this.removedNodes = [];\n        return mutations;\n      }\n\n      return [];\n    }\n  }]);\n\n  return AsyncObserver;\n}(); // TODO(sorvell): consider instead polyfilling MutationObserver\n// directly so that users do not have to fork their code.\n// Supporting the entire api may be challenging: e.g. filtering out\n// removed nodes in the wrong scope and seeing non-distributing\n// subtree child mutations.\n\n\nvar observe_changes_observeChildren = function observeChildren(node, callback) {\n  var sd = ensureShadyDataForNode(node);\n\n  if (!sd.observer) {\n    sd.observer = new observe_changes_AsyncObserver();\n  }\n\n  sd.observer.callbacks.add(callback);\n  var observer = sd.observer;\n  return {\n    _callback: callback,\n    _observer: observer,\n    _node: node,\n    takeRecords: function takeRecords() {\n      return observer.takeRecords();\n    }\n  };\n};\nvar observe_changes_unobserveChildren = function unobserveChildren(handle) {\n  var observer = handle && handle._observer;\n\n  if (observer) {\n    observer.callbacks.delete(handle._callback);\n\n    if (!observer.callbacks.size) {\n      ensureShadyDataForNode(handle._node).observer = null;\n    }\n  }\n};\nfunction filterMutations(mutations, target) {\n  /** @const {Node} */\n  var targetRootNode = target.getRootNode();\n  return mutations.map(function (mutation) {\n    /** @const {boolean} */\n    var mutationInScope = targetRootNode === mutation.target.getRootNode();\n\n    if (mutationInScope && mutation.addedNodes) {\n      var nodes = Array.from(mutation.addedNodes).filter(function (n) {\n        return targetRootNode === n.getRootNode();\n      });\n\n      if (nodes.length) {\n        mutation = Object.create(mutation);\n        Object.defineProperty(mutation, 'addedNodes', {\n          value: nodes,\n          configurable: true\n        });\n        return mutation;\n      }\n    } else if (mutationInScope) {\n      return mutation;\n    }\n  }).filter(function (m) {\n    return m;\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/native-methods.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nvar native_methods_appendChild = Element.prototype.appendChild;\nvar native_methods_insertBefore = Element.prototype.insertBefore;\nvar native_methods_replaceChild = Element.prototype.replaceChild;\nvar native_methods_removeChild = Element.prototype.removeChild;\nvar native_methods_setAttribute = Element.prototype.setAttribute;\nvar native_methods_removeAttribute = Element.prototype.removeAttribute;\nvar native_methods_cloneNode = Element.prototype.cloneNode;\nvar native_methods_importNode = Document.prototype.importNode;\nvar addEventListener = Element.prototype.addEventListener;\nvar removeEventListener = Element.prototype.removeEventListener;\nvar windowAddEventListener = Window.prototype.addEventListener;\nvar windowRemoveEventListener = Window.prototype.removeEventListener;\nvar native_methods_dispatchEvent = Element.prototype.dispatchEvent;\nvar native_methods_contains = Node.prototype.contains || HTMLElement.prototype.contains;\nvar native_methods_getElementById = Document.prototype.getElementById;\nvar elementQuerySelector = Element.prototype.querySelector;\nvar fragmentQuerySelector = DocumentFragment.prototype.querySelector;\nvar documentQuerySelector = Document.prototype.querySelector;\nvar native_methods_querySelector =\n/** @this {Element|Document|DocumentFragment} */\nfunction querySelector(selector) {\n  switch (this.nodeType) {\n    case Node.ELEMENT_NODE:\n      return elementQuerySelector.call(\n      /** @type {Element} */\n      this, selector);\n\n    case Node.DOCUMENT_NODE:\n      return documentQuerySelector.call(\n      /** @type {Document} */\n      this, selector);\n\n    default:\n      return fragmentQuerySelector.call(this, selector);\n  }\n};\nvar elementQuerySelectorAll = Element.prototype.querySelectorAll;\nvar fragmentQuerySelectorAll = DocumentFragment.prototype.querySelectorAll;\nvar documentQuerySelectorAll = Document.prototype.querySelectorAll;\nvar native_methods_querySelectorAll =\n/** @this {Element|Document|DocumentFragment} */\nfunction querySelectorAll(selector) {\n  switch (this.nodeType) {\n    case Node.ELEMENT_NODE:\n      return elementQuerySelectorAll.call(\n      /** @type {Element} */\n      this, selector);\n\n    case Node.DOCUMENT_NODE:\n      return documentQuerySelectorAll.call(\n      /** @type {Document} */\n      this, selector);\n\n    default:\n      return fragmentQuerySelectorAll.call(this, selector);\n  }\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/innerHTML.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n// Cribbed from ShadowDOM polyfill\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n/////////////////////////////////////////////////////////////////////////////\n// innerHTML and outerHTML\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\nvar escapeAttrRegExp = /[&\\u00A0\"]/g;\nvar escapeDataRegExp = /[&\\u00A0<>]/g;\n\nfunction escapeReplace(c) {\n  switch (c) {\n    case '&':\n      return '&amp;';\n\n    case '<':\n      return '&lt;';\n\n    case '>':\n      return '&gt;';\n\n    case '\"':\n      return '&quot;';\n\n    case \"\\xA0\":\n      return '&nbsp;';\n  }\n}\n\nfunction escapeAttr(s) {\n  return s.replace(escapeAttrRegExp, escapeReplace);\n}\n\nfunction escapeData(s) {\n  return s.replace(escapeDataRegExp, escapeReplace);\n}\n\nfunction makeSet(arr) {\n  var set = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    set[arr[i]] = true;\n  }\n\n  return set;\n} // http://www.whatwg.org/specs/web-apps/current-work/#void-elements\n\n\nvar voidElements = makeSet(['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);\nvar plaintextParents = makeSet(['style', 'script', 'xmp', 'iframe', 'noembed', 'noframes', 'plaintext', 'noscript']);\n/**\n * @param {Node} node\n * @param {Node} parentNode\n * @param {Function=} callback\n */\n\nfunction getOuterHTML(node, parentNode, callback) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n      {\n        var tagName = node.localName;\n        var s = '<' + tagName;\n        var attrs = node.attributes;\n\n        for (var i = 0, attr; attr = attrs[i]; i++) {\n          s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n        }\n\n        s += '>';\n\n        if (voidElements[tagName]) {\n          return s;\n        }\n\n        return s + getInnerHTML(node, callback) + '</' + tagName + '>';\n      }\n\n    case Node.TEXT_NODE:\n      {\n        var data =\n        /** @type {Text} */\n        node.data;\n\n        if (parentNode && plaintextParents[parentNode.localName]) {\n          return data;\n        }\n\n        return escapeData(data);\n      }\n\n    case Node.COMMENT_NODE:\n      {\n        return '<!--' +\n        /** @type {Comment} */\n        node.data + '-->';\n      }\n\n    default:\n      {\n        window.console.error(node);\n        throw new Error('not implemented');\n      }\n  }\n}\n/**\n * @param {Node} node\n * @param {Function=} callback\n */\n\nfunction getInnerHTML(node, callback) {\n  if (node.localName === 'template') {\n    node =\n    /** @type {HTMLTemplateElement} */\n    node.content;\n  }\n\n  var s = '';\n  var c$ = callback ? callback(node) : node.childNodes;\n\n  for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {\n    s += getOuterHTML(child, node, callback);\n  }\n\n  return s;\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/native-tree-walker.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\nvar nodeWalker = document.createTreeWalker(document, NodeFilter.SHOW_ALL, null, false);\nvar elementWalker = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT, null, false);\nfunction parentNode(node) {\n  nodeWalker.currentNode = node;\n  return nodeWalker.parentNode();\n}\nfunction native_tree_walker_firstChild(node) {\n  nodeWalker.currentNode = node;\n  return nodeWalker.firstChild();\n}\nfunction lastChild(node) {\n  nodeWalker.currentNode = node;\n  return nodeWalker.lastChild();\n}\nfunction previousSibling(node) {\n  nodeWalker.currentNode = node;\n  return nodeWalker.previousSibling();\n}\nfunction nextSibling(node) {\n  nodeWalker.currentNode = node;\n  return nodeWalker.nextSibling();\n}\nfunction native_tree_walker_childNodes(node) {\n  var nodes = [];\n  nodeWalker.currentNode = node;\n  var n = nodeWalker.firstChild();\n\n  while (n) {\n    nodes.push(n);\n    n = nodeWalker.nextSibling();\n  }\n\n  return nodes;\n}\nfunction parentElement(node) {\n  elementWalker.currentNode = node;\n  return elementWalker.parentNode();\n}\nfunction firstElementChild(node) {\n  elementWalker.currentNode = node;\n  return elementWalker.firstChild();\n}\nfunction lastElementChild(node) {\n  elementWalker.currentNode = node;\n  return elementWalker.lastChild();\n}\nfunction previousElementSibling(node) {\n  elementWalker.currentNode = node;\n  return elementWalker.previousSibling();\n}\nfunction nextElementSibling(node) {\n  elementWalker.currentNode = node;\n  return elementWalker.nextSibling();\n}\nfunction native_tree_walker_children(node) {\n  var nodes = [];\n  elementWalker.currentNode = node;\n  var n = elementWalker.firstChild();\n\n  while (n) {\n    nodes.push(n);\n    n = elementWalker.nextSibling();\n  }\n\n  return createPolyfilledHTMLCollection(nodes);\n}\nfunction innerHTML(node) {\n  return getInnerHTML(node, function (n) {\n    return native_tree_walker_childNodes(n);\n  });\n}\nfunction textContent(node) {\n  /* eslint-disable no-case-declarations */\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n    case Node.DOCUMENT_FRAGMENT_NODE:\n      var textWalker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, null, false);\n      var content = '',\n          n;\n\n      while (n = textWalker.nextNode()) {\n        // TODO(sorvell): can't use textContent since we patch it on Node.prototype!\n        // However, should probably patch it only on element.\n        content += n.nodeValue;\n      }\n\n      return content;\n\n    default:\n      return node.nodeValue;\n  }\n  /* eslint-enable */\n\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/native-tree-accessors.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\nvar hasDescriptors = settings.hasDescriptors; // Find descriptor on the \"lowest\" native prototype. Safe as these are not\n// overridden and we call these on nodes.\n\nvar nativeProtos = [Node.prototype, Element.prototype, HTMLElement.prototype]; // note, avoid Array.find for IE11 compat.\n\nfunction findNativeProtoWithDescriptor(name) {\n  for (var i = 0; i < nativeProtos.length; i++) {\n    var proto = nativeProtos[i];\n\n    if (proto.hasOwnProperty(name)) {\n      return proto;\n    }\n  }\n}\n\nfunction findNodeDescriptor(name) {\n  var proto = findNativeProtoWithDescriptor(name);\n\n  if (!proto) {\n    throw Error(\"Could not find descriptor for \".concat(name));\n  }\n\n  return Object.getOwnPropertyDescriptor(proto, name);\n}\n\nvar nodeAccessors = hasDescriptors ? {\n  parentNode: findNodeDescriptor('parentNode'),\n  firstChild: findNodeDescriptor('firstChild'),\n  lastChild: findNodeDescriptor('lastChild'),\n  previousSibling: findNodeDescriptor('previousSibling'),\n  nextSibling: findNodeDescriptor('nextSibling'),\n  childNodes: findNodeDescriptor('childNodes'),\n  parentElement: findNodeDescriptor('parentElement'),\n  previousElementSibling: findNodeDescriptor('previousElementSibling'),\n  nextElementSibling: findNodeDescriptor('nextElementSibling'),\n  innerHTML: findNodeDescriptor('innerHTML'),\n  textContent: findNodeDescriptor('textContent'),\n  firstElementChild: findNodeDescriptor('firstElementChild'),\n  lastElementChild: findNodeDescriptor('lastElementChild'),\n  children: findNodeDescriptor('children')\n} : {};\nvar fragmentAccessors = hasDescriptors ? {\n  firstElementChild: Object.getOwnPropertyDescriptor(DocumentFragment.prototype, 'firstElementChild'),\n  lastElementChild: Object.getOwnPropertyDescriptor(DocumentFragment.prototype, 'lastElementChild'),\n  children: Object.getOwnPropertyDescriptor(DocumentFragment.prototype, 'children')\n} : {};\nvar documentAccessors = hasDescriptors ? {\n  firstElementChild: Object.getOwnPropertyDescriptor(Document.prototype, 'firstElementChild'),\n  lastElementChild: Object.getOwnPropertyDescriptor(Document.prototype, 'lastElementChild'),\n  children: Object.getOwnPropertyDescriptor(Document.prototype, 'children')\n} : {};\nfunction native_tree_accessors_parentNode(node) {\n  return nodeAccessors.parentNode.get.call(node);\n}\nfunction native_tree_accessors_firstChild(node) {\n  return nodeAccessors.firstChild.get.call(node);\n}\nfunction native_tree_accessors_lastChild(node) {\n  return nodeAccessors.lastChild.get.call(node);\n}\nfunction native_tree_accessors_previousSibling(node) {\n  return nodeAccessors.previousSibling.get.call(node);\n}\nfunction native_tree_accessors_nextSibling(node) {\n  return nodeAccessors.nextSibling.get.call(node);\n}\nfunction native_tree_accessors_childNodes(node) {\n  return Array.prototype.slice.call(nodeAccessors.childNodes.get.call(node));\n}\nfunction native_tree_accessors_parentElement(node) {\n  return nodeAccessors.parentElement.get.call(node);\n}\nfunction native_tree_accessors_previousElementSibling(node) {\n  return nodeAccessors.previousElementSibling.get.call(node);\n}\nfunction native_tree_accessors_nextElementSibling(node) {\n  return nodeAccessors.nextElementSibling.get.call(node);\n}\nfunction native_tree_accessors_innerHTML(node) {\n  return nodeAccessors.innerHTML.get.call(node);\n}\nfunction native_tree_accessors_textContent(node) {\n  return nodeAccessors.textContent.get.call(node);\n}\nfunction native_tree_accessors_children(node) {\n  switch (node.nodeType) {\n    case Node.DOCUMENT_FRAGMENT_NODE:\n      return fragmentAccessors.children.get.call(node);\n\n    case Node.DOCUMENT_NODE:\n      return documentAccessors.children.get.call(node);\n\n    default:\n      return nodeAccessors.children.get.call(node);\n  }\n}\nfunction native_tree_accessors_firstElementChild(node) {\n  switch (node.nodeType) {\n    case Node.DOCUMENT_FRAGMENT_NODE:\n      return fragmentAccessors.firstElementChild.get.call(node);\n\n    case Node.DOCUMENT_NODE:\n      return documentAccessors.firstElementChild.get.call(node);\n\n    default:\n      return nodeAccessors.firstElementChild.get.call(node);\n  }\n}\nfunction native_tree_accessors_lastElementChild(node) {\n  switch (node.nodeType) {\n    case Node.DOCUMENT_FRAGMENT_NODE:\n      return fragmentAccessors.lastElementChild.get.call(node);\n\n    case Node.DOCUMENT_NODE:\n      return documentAccessors.lastElementChild.get.call(node);\n\n    default:\n      return nodeAccessors.lastElementChild.get.call(node);\n  }\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/native-tree.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar accessors = settings.useNativeAccessors ? native_tree_accessors_namespaceObject : native_tree_walker_namespaceObject;\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-accessors.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n\nfunction clearNode(node) {\n  while (node.firstChild) {\n    node.removeChild(node.firstChild);\n  }\n}\n\nvar patch_accessors_hasDescriptors = settings.hasDescriptors;\nvar inertDoc = document.implementation.createHTMLDocument('inert');\nvar nativeIsConnectedAccessors =\n/** @type {ObjectPropertyDescriptor} */\nObject.getOwnPropertyDescriptor(Node.prototype, 'isConnected');\nvar nativeIsConnected = nativeIsConnectedAccessors && nativeIsConnectedAccessors.get;\nvar nativeActiveElementDescriptor =\n/** @type {ObjectPropertyDescriptor} */\nObject.getOwnPropertyDescriptor(Document.prototype, 'activeElement');\n\nfunction getDocumentActiveElement() {\n  if (nativeActiveElementDescriptor && nativeActiveElementDescriptor.get) {\n    return nativeActiveElementDescriptor.get.call(document);\n  } else if (!settings.hasDescriptors) {\n    return document.activeElement;\n  }\n}\n\nfunction activeElementForNode(node) {\n  var active = getDocumentActiveElement(); // In IE11, activeElement might be an empty object if the document is\n  // contained in an iframe.\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10998788/\n\n  if (!active || !active.nodeType) {\n    return null;\n  }\n\n  var isShadyRoot = !!utils_isShadyRoot(node);\n\n  if (node !== document) {\n    // If this node isn't a document or shady root, then it doesn't have\n    // an active element.\n    if (!isShadyRoot) {\n      return null;\n    } // If this shady root's host is the active element or the active\n    // element is not a descendant of the host (in the composed tree),\n    // then it doesn't have an active element.\n\n\n    if (node.host === active || !native_methods_contains.call(node.host, active)) {\n      return null;\n    }\n  } // This node is either the document or a shady root of which the active\n  // element is a (composed) descendant of its host; iterate upwards to\n  // find the active element's most shallow host within it.\n\n\n  var activeRoot = ownerShadyRootForNode(active);\n\n  while (activeRoot && activeRoot !== node) {\n    active = activeRoot.host;\n    activeRoot = ownerShadyRootForNode(active);\n  }\n\n  if (node === document) {\n    // This node is the document, so activeRoot should be null.\n    return activeRoot ? null : active;\n  } else {\n    // This node is a non-document shady root, and it should be\n    // activeRoot.\n    return activeRoot === node ? active : null;\n  }\n}\n\nvar OutsideAccessors = {\n  parentElement: {\n    /** @this {Node} */\n    get: function get() {\n      var nodeData = shadyDataForNode(this);\n      var l = nodeData && nodeData.parentNode;\n\n      if (l && l.nodeType !== Node.ELEMENT_NODE) {\n        l = null;\n      }\n\n      return l !== undefined ? l : accessors.parentElement(this);\n    },\n    configurable: true\n  },\n  parentNode: {\n    /** @this {Node} */\n    get: function get() {\n      var nodeData = shadyDataForNode(this);\n      var l = nodeData && nodeData.parentNode;\n      return l !== undefined ? l : accessors.parentNode(this);\n    },\n    configurable: true\n  },\n  nextSibling: {\n    /** @this {Node} */\n    get: function get() {\n      var nodeData = shadyDataForNode(this);\n      var l = nodeData && nodeData.nextSibling;\n      return l !== undefined ? l : accessors.nextSibling(this);\n    },\n    configurable: true\n  },\n  previousSibling: {\n    /** @this {Node} */\n    get: function get() {\n      var nodeData = shadyDataForNode(this);\n      var l = nodeData && nodeData.previousSibling;\n      return l !== undefined ? l : accessors.previousSibling(this);\n    },\n    configurable: true\n  },\n  // fragment, element, document\n  nextElementSibling: {\n    /**\n     * @this {HTMLElement}\n     */\n    get: function get() {\n      var nodeData = shadyDataForNode(this);\n\n      if (nodeData && nodeData.nextSibling !== undefined) {\n        var n = this.nextSibling;\n\n        while (n && n.nodeType !== Node.ELEMENT_NODE) {\n          n = n.nextSibling;\n        }\n\n        return n;\n      } else {\n        return accessors.nextElementSibling(this);\n      }\n    },\n    configurable: true\n  },\n  previousElementSibling: {\n    /**\n     * @this {HTMLElement}\n     */\n    get: function get() {\n      var nodeData = shadyDataForNode(this);\n\n      if (nodeData && nodeData.previousSibling !== undefined) {\n        var n = this.previousSibling;\n\n        while (n && n.nodeType !== Node.ELEMENT_NODE) {\n          n = n.previousSibling;\n        }\n\n        return n;\n      } else {\n        return accessors.previousElementSibling(this);\n      }\n    },\n    configurable: true\n  }\n};\nvar ClassNameAccessor = {\n  className: {\n    /**\n     * @this {HTMLElement}\n     */\n    get: function get() {\n      return this.getAttribute('class') || '';\n    },\n\n    /**\n     * @this {HTMLElement}\n     */\n    set: function set(value) {\n      this.setAttribute('class', value);\n    },\n    configurable: true\n  }\n};\nvar IsConnectedAccessor = {\n  isConnected: {\n    /**\n     * @this {Node}\n     */\n    get: function get() {\n      if (nativeIsConnected && nativeIsConnected.call(this)) {\n        return true;\n      }\n\n      if (this.nodeType == Node.DOCUMENT_FRAGMENT_NODE) {\n        return false;\n      } // Fast path for distributed nodes.\n\n\n      var ownerDocument = this.ownerDocument;\n\n      if (hasDocumentContains) {\n        if (native_methods_contains.call(ownerDocument, this)) {\n          return true;\n        }\n      } else if (ownerDocument.documentElement && native_methods_contains.call(ownerDocument.documentElement, this)) {\n        return true;\n      } // Slow path for non-distributed nodes.\n\n\n      var node = this;\n\n      while (node && !(node instanceof Document)) {\n        node = node.parentNode || (utils_isShadyRoot(node) ?\n        /** @type {ShadowRoot} */\n        node.host : undefined);\n      }\n\n      return !!(node && node instanceof Document);\n    },\n    configurable: true\n  }\n};\nvar InsideAccessors = {\n  childNodes: {\n    /**\n     * @this {HTMLElement}\n     */\n    get: function get() {\n      var childNodes;\n\n      if (isTrackingLogicalChildNodes(this)) {\n        var nodeData = shadyDataForNode(this);\n\n        if (!nodeData.childNodes) {\n          nodeData.childNodes = [];\n\n          for (var n = this.firstChild; n; n = n.nextSibling) {\n            nodeData.childNodes.push(n);\n          }\n        }\n\n        childNodes = nodeData.childNodes;\n      } else {\n        childNodes = accessors.childNodes(this);\n      }\n\n      childNodes.item = function (index) {\n        return childNodes[index];\n      };\n\n      return childNodes;\n    },\n    configurable: true\n  },\n  childElementCount: {\n    /** @this {HTMLElement} */\n    get: function get() {\n      return this.children.length;\n    },\n    configurable: true\n  },\n  firstChild: {\n    /** @this {HTMLElement} */\n    get: function get() {\n      var nodeData = shadyDataForNode(this);\n      var l = nodeData && nodeData.firstChild;\n      return l !== undefined ? l : accessors.firstChild(this);\n    },\n    configurable: true\n  },\n  lastChild: {\n    /** @this {HTMLElement} */\n    get: function get() {\n      var nodeData = shadyDataForNode(this);\n      var l = nodeData && nodeData.lastChild;\n      return l !== undefined ? l : accessors.lastChild(this);\n    },\n    configurable: true\n  },\n  textContent: {\n    /**\n     * @this {HTMLElement}\n     */\n    get: function get() {\n      if (isTrackingLogicalChildNodes(this)) {\n        var tc = [];\n\n        for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {\n          if (c.nodeType !== Node.COMMENT_NODE) {\n            tc.push(c.textContent);\n          }\n        }\n\n        return tc.join('');\n      } else {\n        return accessors.textContent(this);\n      }\n    },\n\n    /**\n     * @this {HTMLElement}\n     * @param {string} text\n     */\n    set: function set(text) {\n      if (typeof text === 'undefined' || text === null) {\n        text = '';\n      }\n\n      switch (this.nodeType) {\n        case Node.ELEMENT_NODE:\n        case Node.DOCUMENT_FRAGMENT_NODE:\n          if (!isTrackingLogicalChildNodes(this) && patch_accessors_hasDescriptors) {\n            // may be removing a nested slot but fast path if we know we are not.\n            var firstChild = this.firstChild;\n\n            if (firstChild != this.lastChild || firstChild && firstChild.nodeType != Node.TEXT_NODE) {\n              clearNode(this);\n            }\n\n            nodeAccessors.textContent.set.call(this, text);\n          } else {\n            clearNode(this); // Document fragments must have no childnodes if setting a blank string\n\n            if (text.length > 0 || this.nodeType === Node.ELEMENT_NODE) {\n              this.appendChild(document.createTextNode(text));\n            }\n          }\n\n          break;\n\n        default:\n          // TODO(sorvell): can't do this if patch nodeValue.\n          this.nodeValue = text;\n          break;\n      }\n    },\n    configurable: true\n  },\n  // fragment, element, document\n  firstElementChild: {\n    /**\n     * @this {HTMLElement}\n     */\n    get: function get() {\n      var nodeData = shadyDataForNode(this);\n\n      if (nodeData && nodeData.firstChild !== undefined) {\n        var n = this.firstChild;\n\n        while (n && n.nodeType !== Node.ELEMENT_NODE) {\n          n = n.nextSibling;\n        }\n\n        return n;\n      } else {\n        return accessors.firstElementChild(this);\n      }\n    },\n    configurable: true\n  },\n  lastElementChild: {\n    /**\n     * @this {HTMLElement}\n     */\n    get: function get() {\n      var nodeData = shadyDataForNode(this);\n\n      if (nodeData && nodeData.lastChild !== undefined) {\n        var n = this.lastChild;\n\n        while (n && n.nodeType !== Node.ELEMENT_NODE) {\n          n = n.previousSibling;\n        }\n\n        return n;\n      } else {\n        return accessors.lastElementChild(this);\n      }\n    },\n    configurable: true\n  },\n  children: {\n    /**\n     * @this {HTMLElement}\n     */\n    get: function get() {\n      if (!isTrackingLogicalChildNodes(this)) {\n        return accessors.children(this);\n      }\n\n      return createPolyfilledHTMLCollection(Array.prototype.filter.call(this.childNodes, function (n) {\n        return n.nodeType === Node.ELEMENT_NODE;\n      }));\n    },\n    configurable: true\n  },\n  // element (HTMLElement on IE11)\n  innerHTML: {\n    /**\n     * @this {HTMLElement}\n     */\n    get: function get() {\n      if (isTrackingLogicalChildNodes(this)) {\n        var content = this.localName === 'template' ?\n        /** @type {HTMLTemplateElement} */\n        this.content : this;\n        return getInnerHTML(content);\n      } else {\n        return accessors.innerHTML(this);\n      }\n    },\n\n    /**\n     * @this {HTMLElement}\n     */\n    set: function set(text) {\n      var content = this.localName === 'template' ?\n      /** @type {HTMLTemplateElement} */\n      this.content : this;\n      clearNode(content);\n      var containerName = this.localName || 'div';\n      var htmlContainer;\n\n      if (!this.namespaceURI || this.namespaceURI === inertDoc.namespaceURI) {\n        htmlContainer = inertDoc.createElement(containerName);\n      } else {\n        htmlContainer = inertDoc.createElementNS(this.namespaceURI, containerName);\n      }\n\n      if (patch_accessors_hasDescriptors) {\n        nodeAccessors.innerHTML.set.call(htmlContainer, text);\n      } else {\n        htmlContainer.innerHTML = text;\n      }\n\n      var newContent = this.localName === 'template' ?\n      /** @type {HTMLTemplateElement} */\n      htmlContainer.content : htmlContainer;\n\n      while (newContent.firstChild) {\n        content.appendChild(newContent.firstChild);\n      }\n    },\n    configurable: true\n  }\n}; // Note: Can be patched on element prototype on all browsers.\n// Must be patched on instance on browsers that support native Shadow DOM\n// but do not have builtin accessors (old Chrome).\n\nvar ShadowRootAccessor = {\n  shadowRoot: {\n    /**\n     * @this {HTMLElement}\n     */\n    get: function get() {\n      var nodeData = shadyDataForNode(this);\n      return nodeData && nodeData.publicRoot || null;\n    },\n    configurable: true\n  }\n}; // Note: Can be patched on document prototype on browsers with builtin accessors.\n// Must be patched separately on simulated ShadowRoot.\n// Must be patched as `_activeElement` on browsers without builtin accessors.\n\nvar ActiveElementAccessor = {\n  activeElement: {\n    /**\n     * @this {HTMLElement}\n     */\n    get: function get() {\n      return activeElementForNode(this);\n    },\n\n    /**\n     * @this {HTMLElement}\n     */\n    set: function set() {},\n    configurable: true\n  }\n}; // patch a group of descriptors on an object only if it exists or if the `force`\n// argument is true.\n\n/**\n * @param {!Object} obj\n * @param {!Object} descriptors\n * @param {boolean=} force\n */\n\nfunction patchAccessorGroup(obj, descriptors, force) {\n  for (var p in descriptors) {\n    var objDesc = Object.getOwnPropertyDescriptor(obj, p);\n\n    if (objDesc && objDesc.configurable || !objDesc && force) {\n      Object.defineProperty(obj, p, descriptors[p]);\n    } else if (force) {\n      console.warn('Could not define', p, 'on', obj); // eslint-disable-line no-console\n    }\n  }\n} // patch dom accessors on proto where they exist\n\n\nfunction patchAccessors(proto) {\n  patchAccessorGroup(proto, OutsideAccessors);\n  patchAccessorGroup(proto, ClassNameAccessor);\n  patchAccessorGroup(proto, InsideAccessors);\n  patchAccessorGroup(proto, ActiveElementAccessor);\n}\nfunction patchShadowRootAccessors(proto) {\n  proto.__proto__ = DocumentFragment.prototype; // ensure element descriptors (IE/Edge don't have em)\n\n  patchAccessorGroup(proto, OutsideAccessors, true);\n  patchAccessorGroup(proto, InsideAccessors, true);\n  patchAccessorGroup(proto, ActiveElementAccessor, true); // Ensure native properties are all safely wrapped since ShadowRoot is not an\n  // actual DocumentFragment instance.\n\n  Object.defineProperties(proto, {\n    nodeType: {\n      value: Node.DOCUMENT_FRAGMENT_NODE,\n      configurable: true\n    },\n    nodeName: {\n      value: '#document-fragment',\n      configurable: true\n    },\n    nodeValue: {\n      value: null,\n      configurable: true\n    }\n  }); // make undefined\n\n  ['localName', 'namespaceURI', 'prefix'].forEach(function (prop) {\n    Object.defineProperty(proto, prop, {\n      value: undefined,\n      configurable: true\n    });\n  }); // defer properties to host\n\n  ['ownerDocument', 'baseURI', 'isConnected'].forEach(function (prop) {\n    Object.defineProperty(proto, prop, {\n      get: function get() {\n        return this.host[prop];\n      },\n      configurable: true\n    });\n  });\n} // ensure an element has patched \"outside\" accessors; no-op when not needed\n\nvar patchOutsideElementAccessors = settings.hasDescriptors ? function () {} : function (element) {\n  var sd = ensureShadyDataForNode(element);\n\n  if (!sd.__outsideAccessors) {\n    sd.__outsideAccessors = true;\n    patchAccessorGroup(element, OutsideAccessors, true);\n    patchAccessorGroup(element, ClassNameAccessor, true);\n  }\n}; // ensure an element has patched \"inside\" accessors; no-op when not needed\n\nvar patchInsideElementAccessors = settings.hasDescriptors ? function () {} : function (element) {\n  var sd = ensureShadyDataForNode(element);\n\n  if (!sd.__insideAccessors) {\n    patchAccessorGroup(element, InsideAccessors, true);\n    patchAccessorGroup(element, ShadowRootAccessor, true);\n  }\n};\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/logical-tree.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\nvar logical_tree_childNodes = accessors.childNodes;\nfunction recordInsertBefore(node, container, ref_node) {\n  patchInsideElementAccessors(container);\n  var containerData = ensureShadyDataForNode(container);\n\n  if (containerData.firstChild !== undefined) {\n    containerData.childNodes = null;\n  } // handle document fragments\n\n\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    var c$ = node.childNodes;\n\n    for (var i = 0; i < c$.length; i++) {\n      linkNode(c$[i], container, ref_node);\n    } // cleanup logical dom in doc fragment.\n\n\n    var nodeData = ensureShadyDataForNode(node);\n    var resetTo = nodeData.firstChild !== undefined ? null : undefined;\n    nodeData.firstChild = nodeData.lastChild = resetTo;\n    nodeData.childNodes = resetTo;\n  } else {\n    linkNode(node, container, ref_node);\n  }\n}\n\nfunction linkNode(node, container, ref_node) {\n  patchOutsideElementAccessors(node);\n  ref_node = ref_node || null;\n  var nodeData = ensureShadyDataForNode(node);\n  var containerData = ensureShadyDataForNode(container);\n  var ref_nodeData = ref_node ? ensureShadyDataForNode(ref_node) : null; // update ref_node.previousSibling <-> node\n\n  nodeData.previousSibling = ref_node ? ref_nodeData.previousSibling : container.lastChild;\n  var psd = shadyDataForNode(nodeData.previousSibling);\n\n  if (psd) {\n    psd.nextSibling = node;\n  } // update node <-> ref_node\n\n\n  var nsd = shadyDataForNode(nodeData.nextSibling = ref_node);\n\n  if (nsd) {\n    nsd.previousSibling = node;\n  } // update node <-> container\n\n\n  nodeData.parentNode = container;\n\n  if (ref_node) {\n    if (ref_node === containerData.firstChild) {\n      containerData.firstChild = node;\n    }\n  } else {\n    containerData.lastChild = node;\n\n    if (!containerData.firstChild) {\n      containerData.firstChild = node;\n    }\n  } // remove caching of childNodes\n\n\n  containerData.childNodes = null;\n}\n\nfunction recordRemoveChild(node, container) {\n  var nodeData = ensureShadyDataForNode(node);\n  var containerData = ensureShadyDataForNode(container);\n\n  if (node === containerData.firstChild) {\n    containerData.firstChild = nodeData.nextSibling;\n  }\n\n  if (node === containerData.lastChild) {\n    containerData.lastChild = nodeData.previousSibling;\n  }\n\n  var p = nodeData.previousSibling;\n  var n = nodeData.nextSibling;\n\n  if (p) {\n    ensureShadyDataForNode(p).nextSibling = n;\n  }\n\n  if (n) {\n    ensureShadyDataForNode(n).previousSibling = p;\n  } // When an element is removed, logical data is no longer tracked.\n  // Explicitly set `undefined` here to indicate this. This is disginguished\n  // from `null` which is set if info is null.\n\n\n  nodeData.parentNode = nodeData.previousSibling = nodeData.nextSibling = undefined;\n\n  if (containerData.childNodes !== undefined) {\n    // remove caching of childNodes\n    containerData.childNodes = null;\n  }\n}\n/**\n * @param  {!Node} node\n * @param  {Array<Node>=} nodes\n */\n\nfunction recordChildNodes(node, nodes) {\n  var nodeData = ensureShadyDataForNode(node);\n\n  if (nodeData.firstChild === undefined) {\n    // remove caching of childNodes\n    nodeData.childNodes = null;\n    var c$ = nodes || logical_tree_childNodes(node);\n    nodeData.firstChild = c$[0] || null;\n    nodeData.lastChild = c$[c$.length - 1] || null;\n    patchInsideElementAccessors(node);\n\n    for (var i = 0; i < c$.length; i++) {\n      var n = c$[i];\n      var sd = ensureShadyDataForNode(n);\n      sd.parentNode = node;\n      sd.nextSibling = c$[i + 1] || null;\n      sd.previousSibling = c$[i - 1] || null;\n      patchOutsideElementAccessors(n);\n    }\n  }\n}\n\n\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/logical-mutation.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\nvar logical_mutation_parentNode = accessors.parentNode; // Patched `insertBefore`. Note that all mutations that add nodes are routed\n// here. When a <slot> is added or a node is added to a host with a shadowRoot\n// with a slot, a standard dom `insert` call is aborted and `_asyncRender`\n// is called on the relevant shadowRoot. In all other cases, a standard dom\n// `insert` can be made, but the location and ref_node may need to be changed.\n\n/**\n * @param {!Node} parent\n * @param {Node} node\n * @param {Node=} ref_node\n */\n\nfunction logical_mutation_insertBefore(parent, node, ref_node) {\n  if (node === parent) {\n    throw Error(\"Failed to execute 'appendChild' on 'Node': The new child element contains the parent.\");\n  }\n\n  if (ref_node) {\n    var refData = shadyDataForNode(ref_node);\n    var p = refData && refData.parentNode;\n\n    if (p !== undefined && p !== parent || p === undefined && logical_mutation_parentNode(ref_node) !== parent) {\n      throw Error(\"Failed to execute 'insertBefore' on 'Node': The node \" + \"before which the new node is to be inserted is not a child of this node.\");\n    }\n  }\n\n  if (ref_node === node) {\n    return node;\n  }\n  /** @type {!Array<!HTMLSlotElement>} */\n\n\n  var slotsAdded = [];\n  /** @type {function(!Node, string): void} */\n\n  var scopingFn = addShadyScoping;\n  var ownerRoot = ownerShadyRootForNode(parent);\n  /** @type {string} */\n\n  var newScopeName = ownerRoot ? ownerRoot.host.localName : ''; // remove from existing location\n\n  if (node.parentNode) {\n    // NOTE: avoid node.removeChild as this *can* trigger another patched\n    // method (e.g. custom elements) and we want only the shady method to run.\n    // The following table describes what style scoping actions should happen as a result of this insertion.\n    // document -> shadowRoot: replace\n    // shadowRoot -> shadowRoot: replace\n    // shadowRoot -> shadowRoot of same type: do nothing\n    // shadowRoot -> document: allow unscoping\n    // document -> document: do nothing\n    // The \"same type of shadowRoot\" and \"document to document cases rely on `currentScopeIsCorrect` returning true\n    var oldScopeName = currentScopeForNode(node);\n    logical_mutation_removeChild(node.parentNode, node, Boolean(ownerRoot) || !(node.getRootNode() instanceof ShadowRoot));\n\n    scopingFn = function scopingFn(node, newScopeName) {\n      replaceShadyScoping(node, newScopeName, oldScopeName);\n    };\n  } // add to new parent\n\n\n  var allowNativeInsert = true;\n  var needsScoping = !currentScopeIsCorrect(node, newScopeName);\n\n  if (ownerRoot && (!node['__noInsertionPoint'] || needsScoping)) {\n    treeVisitor(node, function (node) {\n      if (node.localName === 'slot') {\n        slotsAdded.push(\n        /** @type {!HTMLSlotElement} */\n        node);\n      }\n\n      if (needsScoping) {\n        scopingFn(node, newScopeName);\n      }\n    });\n  }\n\n  if (slotsAdded.length) {\n    ownerRoot._addSlots(slotsAdded);\n  } // if a slot is added, must render containing root.\n\n\n  if (parent.localName === 'slot' || slotsAdded.length) {\n    if (ownerRoot) {\n      ownerRoot._asyncRender();\n    }\n  }\n\n  if (isTrackingLogicalChildNodes(parent)) {\n    recordInsertBefore(node, parent, ref_node); // when inserting into a host with a shadowRoot with slot, use\n    // `shadowRoot._asyncRender()` via `attach-shadow` module\n\n    var parentData = shadyDataForNode(parent);\n\n    if (hasShadowRootWithSlot(parent)) {\n      parentData.root._asyncRender();\n\n      allowNativeInsert = false; // when inserting into a host with shadowRoot with NO slot, do nothing\n      // as the node should not be added to composed dome anywhere.\n    } else if (parentData.root) {\n      allowNativeInsert = false;\n    }\n  }\n\n  if (allowNativeInsert) {\n    // if adding to a shadyRoot, add to host instead\n    var container = utils_isShadyRoot(parent) ?\n    /** @type {ShadowRoot} */\n    parent.host : parent; // if ref_node, get the ref_node that's actually in composed dom.\n\n    if (ref_node) {\n      ref_node = firstComposedNode(ref_node);\n      native_methods_insertBefore.call(container, node, ref_node);\n    } else {\n      native_methods_appendChild.call(container, node);\n    } // Since ownerDocument is not patched, it can be incorrect afer this call\n    // if the node is physically appended via distribution. This can result\n    // in the custom elements polyfill not upgrading the node if it's in an inert doc.\n    // We correct this by calling `adoptNode`.\n\n  } else if (node.ownerDocument !== parent.ownerDocument) {\n    parent.ownerDocument.adoptNode(node);\n  }\n\n  scheduleObserver(parent, node);\n  return node;\n}\n/**\n * Patched `removeChild`. Note that all dom \"removals\" are routed here.\n * Removes the given `node` from the element's `children`.\n * This method also performs dom composition.\n * @param {Node} parent\n * @param {Node} node\n * @param {boolean=} skipUnscoping\n*/\n\nfunction logical_mutation_removeChild(parent, node) {\n  var skipUnscoping = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (node.parentNode !== parent) {\n    throw Error('The node to be removed is not a child of this node: ' + node);\n  }\n\n  var preventNativeRemove;\n  var ownerRoot = ownerShadyRootForNode(node);\n  var removingInsertionPoint;\n  var parentData = shadyDataForNode(parent);\n\n  if (isTrackingLogicalChildNodes(parent)) {\n    recordRemoveChild(node, parent);\n\n    if (hasShadowRootWithSlot(parent)) {\n      parentData.root._asyncRender();\n\n      preventNativeRemove = true;\n    }\n  } // unscope a node leaving a ShadowRoot if ShadyCSS is present, and this node\n  // is not going to be rescoped in `insertBefore`\n\n\n  if (getScopingShim() && !skipUnscoping && ownerRoot) {\n    var oldScopeName = currentScopeForNode(node);\n    treeVisitor(node, function (node) {\n      removeShadyScoping(node, oldScopeName);\n    });\n  }\n\n  removeOwnerShadyRoot(node); // if removing slot, must render containing root\n\n  if (ownerRoot) {\n    var changeSlotContent = parent && parent.localName === 'slot';\n\n    if (changeSlotContent) {\n      preventNativeRemove = true;\n    }\n\n    removingInsertionPoint = ownerRoot._removeContainedSlots(node);\n\n    if (removingInsertionPoint || changeSlotContent) {\n      ownerRoot._asyncRender();\n    }\n  }\n\n  if (!preventNativeRemove) {\n    // if removing from a shadyRoot, remove from host instead\n    var container = utils_isShadyRoot(parent) ?\n    /** @type {ShadowRoot} */\n    parent.host : parent; // not guaranteed to physically be in container; e.g.\n    // (1) if parent has a shadyRoot, element may or may not at distributed\n    // location (could be undistributed)\n    // (2) if parent is a slot, element may not ben in composed dom\n\n    if (!(parentData.root || node.localName === 'slot') || container === logical_mutation_parentNode(node)) {\n      native_methods_removeChild.call(container, node);\n    }\n  }\n\n  scheduleObserver(parent, null, node);\n  return node;\n}\n\nfunction removeOwnerShadyRoot(node) {\n  // optimization: only reset the tree if node is actually in a root\n  if (hasCachedOwnerRoot(node)) {\n    var c$ = node.childNodes;\n\n    for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {\n      removeOwnerShadyRoot(n);\n    }\n  }\n\n  var nodeData = shadyDataForNode(node);\n\n  if (nodeData) {\n    nodeData.ownerShadyRoot = undefined;\n  }\n}\n\nfunction hasCachedOwnerRoot(node) {\n  var nodeData = shadyDataForNode(node);\n  return Boolean(nodeData && nodeData.ownerShadyRoot !== undefined);\n}\n/**\n * Finds the first flattened node that is composed in the node's parent.\n * If the given node is a slot, then the first flattened node is returned\n * if it exists, otherwise advance to the node's nextSibling.\n * @param {Node} node within which to find first composed node\n * @returns {Node} first composed node\n */\n\n\nfunction firstComposedNode(node) {\n  var composed = node;\n\n  if (node && node.localName === 'slot') {\n    var nodeData = shadyDataForNode(node);\n    var flattened = nodeData && nodeData.flattenedNodes;\n    composed = flattened && flattened.length ? flattened[0] : firstComposedNode(node.nextSibling);\n  }\n\n  return composed;\n}\n\nfunction hasShadowRootWithSlot(node) {\n  var nodeData = shadyDataForNode(node);\n  var root = nodeData && nodeData.root;\n  return root && root._hasInsertionPoint();\n}\n/**\n * Should be called whenever an attribute changes. If the `slot` attribute\n * changes, provokes rendering if necessary. If a `<slot>` element's `name`\n * attribute changes, updates the root's slot map and renders.\n * @param {Node} node\n * @param {string} name\n */\n\n\nfunction distributeAttributeChange(node, name) {\n  if (name === 'slot') {\n    var parent = node.parentNode;\n\n    if (hasShadowRootWithSlot(parent)) {\n      shadyDataForNode(parent).root._asyncRender();\n    }\n  } else if (node.localName === 'slot' && name === 'name') {\n    var root = ownerShadyRootForNode(node);\n\n    if (root) {\n      root._updateSlotName(node);\n\n      root._asyncRender();\n    }\n  }\n}\n/**\n * @param {Node} node\n * @param {Node=} addedNode\n * @param {Node=} removedNode\n */\n\n\nfunction scheduleObserver(node, addedNode, removedNode) {\n  var nodeData = shadyDataForNode(node);\n  var observer = nodeData && nodeData.observer;\n\n  if (observer) {\n    if (addedNode) {\n      observer.addedNodes.push(addedNode);\n    }\n\n    if (removedNode) {\n      observer.removedNodes.push(removedNode);\n    }\n\n    observer.schedule();\n  }\n}\n/**\n * @param {Node} node\n * @param {Object=} options\n */\n\n\nfunction logical_mutation_getRootNode(node, options) {\n  // eslint-disable-line no-unused-vars\n  if (!node || !node.nodeType) {\n    return;\n  }\n\n  var nodeData = ensureShadyDataForNode(node);\n  var root = nodeData.ownerShadyRoot;\n\n  if (root === undefined) {\n    if (utils_isShadyRoot(node)) {\n      root = node;\n      nodeData.ownerShadyRoot = root;\n    } else {\n      var parent = node.parentNode;\n      root = parent ? logical_mutation_getRootNode(parent) : node; // memo-ize result for performance but only memo-ize\n      // result if node is in the document. This avoids a problem where a root\n      // can be cached while an element is inside a fragment.\n      // If this happens and we cache the result, the value can become stale\n      // because for perf we avoid processing the subtree of added fragments.\n\n      if (native_methods_contains.call(document.documentElement, node)) {\n        nodeData.ownerShadyRoot = root;\n      }\n    }\n  }\n\n  return root;\n} // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,\n// but it's also generally useful to recurse through the element tree\n// and is used by Polymer's styling system.\n\n/**\n * @param {Node} node\n * @param {Function} matcher\n * @param {Function=} halter\n */\n\nfunction query(node, matcher, halter) {\n  var list = [];\n  queryElements(node.childNodes, matcher, halter, list);\n  return list;\n}\n\nfunction queryElements(elements, matcher, halter, list) {\n  for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {\n    if (c.nodeType === Node.ELEMENT_NODE && queryElement(c, matcher, halter, list)) {\n      return true;\n    }\n  }\n}\n\nfunction queryElement(node, matcher, halter, list) {\n  var result = matcher(node);\n\n  if (result) {\n    list.push(node);\n  }\n\n  if (halter && halter(result)) {\n    return result;\n  }\n\n  queryElements(node.childNodes, matcher, halter, list);\n}\n\nfunction renderRootNode(element) {\n  var root = element.getRootNode();\n\n  if (utils_isShadyRoot(root)) {\n    root._render();\n  }\n}\nvar logical_mutation_scopingShim = null;\n\nfunction getScopingShim() {\n  if (!logical_mutation_scopingShim) {\n    logical_mutation_scopingShim = window['ShadyCSS'] && window['ShadyCSS']['ScopingShim'];\n  }\n\n  return logical_mutation_scopingShim || null;\n}\n\nfunction logical_mutation_setAttribute(node, attr, value) {\n  var scopingShim = getScopingShim();\n\n  if (scopingShim && attr === 'class') {\n    scopingShim['setElementClass'](node, value);\n  } else {\n    native_methods_setAttribute.call(node, attr, value);\n    distributeAttributeChange(node, attr);\n  }\n}\nfunction logical_mutation_removeAttribute(node, attr) {\n  native_methods_removeAttribute.call(node, attr);\n  distributeAttributeChange(node, attr);\n}\nfunction logical_mutation_cloneNode(node, deep) {\n  if (node.localName == 'template') {\n    return native_methods_cloneNode.call(node, deep);\n  } else {\n    var n = native_methods_cloneNode.call(node, false); // Attribute nodes historically had childNodes, but they have later\n    // been removed from the spec.\n    // Make sure we do not do a deep clone on them for old browsers (IE11)\n\n    if (deep && n.nodeType !== Node.ATTRIBUTE_NODE) {\n      var c$ = node.childNodes;\n\n      for (var i = 0, nc; i < c$.length; i++) {\n        nc = c$[i].cloneNode(true);\n        n.appendChild(nc);\n      }\n    }\n\n    return n;\n  }\n} // note: Though not technically correct, we fast path `importNode`\n// when called on a node not owned by the main document.\n// This allows, for example, elements that cannot\n// contain custom elements and are therefore not likely to contain shadowRoots\n// to cloned natively. This is a fairly significant performance win.\n\nfunction logical_mutation_importNode(node, deep) {\n  // A template element normally has no children with shadowRoots, so make\n  // sure we always make a deep copy to correctly construct the template.content\n  if (node.ownerDocument !== document || node.localName === 'template') {\n    return native_methods_importNode.call(document, node, deep);\n  }\n\n  var n = native_methods_importNode.call(document, node, false);\n\n  if (deep) {\n    var c$ = node.childNodes;\n\n    for (var i = 0, nc; i < c$.length; i++) {\n      nc = logical_mutation_importNode(c$[i], true);\n      n.appendChild(nc);\n    }\n  }\n\n  return n;\n}\n/**\n * @param {!Node} node\n * @param {string} newScopeName\n */\n\nfunction addShadyScoping(node, newScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return;\n  }\n\n  scopingShim['scopeNode'](node, newScopeName);\n}\n/**\n * @param {!Node} node\n * @param {string} currentScopeName\n */\n\n\nfunction removeShadyScoping(node, currentScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return;\n  }\n\n  scopingShim['unscopeNode'](node, currentScopeName);\n}\n/**\n * @param {!Node} node\n * @param {string} newScopeName\n * @param {string} oldScopeName\n */\n\n\nfunction replaceShadyScoping(node, newScopeName, oldScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return;\n  }\n\n  removeShadyScoping(node, oldScopeName);\n  addShadyScoping(node, newScopeName);\n}\n/**\n * @param {!Node} node\n * @param {string} newScopeName\n * @return {boolean}\n */\n\n\nfunction currentScopeIsCorrect(node, newScopeName) {\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return true;\n  }\n\n  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    // NOTE: as an optimization, only check that all the top-level children\n    // have the correct scope.\n    var correctScope = true;\n\n    for (var idx = 0; correctScope && idx < node.childNodes.length; idx++) {\n      correctScope = correctScope && currentScopeIsCorrect(node.childNodes[idx], newScopeName);\n    }\n\n    return correctScope;\n  }\n\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return true;\n  }\n\n  var currentScope = scopingShim['currentScopeForNode'](node);\n  return currentScope === newScopeName;\n}\n/**\n * @param {!Node} node\n * @return {string}\n */\n\n\nfunction currentScopeForNode(node) {\n  if (node.nodeType !== Node.ELEMENT_NODE) {\n    return '';\n  }\n\n  var scopingShim = getScopingShim();\n\n  if (!scopingShim) {\n    return '';\n  }\n\n  return scopingShim['currentScopeForNode'](node);\n}\n/**\n * Walk over a node's tree and apply visitorFn to each element node\n *\n * @param {Node} node\n * @param {function(!Node):void} visitorFn\n */\n\n\nfunction treeVisitor(node, visitorFn) {\n  if (!node) {\n    return;\n  } // this check is necessary if `node` is a Document Fragment\n\n\n  if (node.nodeType === Node.ELEMENT_NODE) {\n    visitorFn(node);\n  }\n\n  for (var idx = 0, n; idx < node.childNodes.length; idx++) {\n    n = node.childNodes[idx];\n\n    if (n.nodeType === Node.ELEMENT_NODE) {\n      treeVisitor(n, visitorFn);\n    }\n  }\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-events.js\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n/*\nMake this name unique so it is unlikely to conflict with properties on objects passed to `addEventListener`\nhttps://github.com/webcomponents/shadydom/issues/173\n*/\n\nvar\n/** string */\neventWrappersName = \"__eventWrappers\".concat(Date.now());\n/** @type {?function(!Event): boolean} */\n\nvar composedGetter = function () {\n  var composedProp = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');\n  return composedProp ? function (ev) {\n    return composedProp.get.call(ev);\n  } : null;\n}(); // https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\n\n\nvar alwaysComposed = {\n  'blur': true,\n  'focus': true,\n  'focusin': true,\n  'focusout': true,\n  'click': true,\n  'dblclick': true,\n  'mousedown': true,\n  'mouseenter': true,\n  'mouseleave': true,\n  'mousemove': true,\n  'mouseout': true,\n  'mouseover': true,\n  'mouseup': true,\n  'wheel': true,\n  'beforeinput': true,\n  'input': true,\n  'keydown': true,\n  'keyup': true,\n  'compositionstart': true,\n  'compositionupdate': true,\n  'compositionend': true,\n  'touchstart': true,\n  'touchend': true,\n  'touchmove': true,\n  'touchcancel': true,\n  'pointerover': true,\n  'pointerenter': true,\n  'pointerdown': true,\n  'pointermove': true,\n  'pointerup': true,\n  'pointercancel': true,\n  'pointerout': true,\n  'pointerleave': true,\n  'gotpointercapture': true,\n  'lostpointercapture': true,\n  'dragstart': true,\n  'drag': true,\n  'dragenter': true,\n  'dragleave': true,\n  'dragover': true,\n  'drop': true,\n  'dragend': true,\n  'DOMActivate': true,\n  'DOMFocusIn': true,\n  'DOMFocusOut': true,\n  'keypress': true\n};\nvar unpatchedEvents = {\n  'DOMAttrModified': true,\n  'DOMAttributeNameChanged': true,\n  'DOMCharacterDataModified': true,\n  'DOMElementNameChanged': true,\n  'DOMNodeInserted': true,\n  'DOMNodeInsertedIntoDocument': true,\n  'DOMNodeRemoved': true,\n  'DOMNodeRemovedFromDocument': true,\n  'DOMSubtreeModified': true\n};\n\nfunction pathComposer(startNode, composed) {\n  var composedPath = [];\n  var current = startNode;\n  var startRoot = startNode === window ? window : startNode.getRootNode();\n\n  while (current) {\n    composedPath.push(current);\n\n    if (current.assignedSlot) {\n      current = current.assignedSlot;\n    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n      current = current.host;\n    } else {\n      current = current.parentNode;\n    }\n  } // event composedPath includes window when startNode's ownerRoot is document\n\n\n  if (composedPath[composedPath.length - 1] === document) {\n    composedPath.push(window);\n  }\n\n  return composedPath;\n}\n\nfunction retarget(refNode, path) {\n  if (!utils_isShadyRoot) {\n    return refNode;\n  } // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n  // shadow-including inclusive ancestor, return ANCESTOR.\n\n\n  var refNodePath = pathComposer(refNode, true);\n  var p$ = path;\n\n  for (var i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n    ancestor = p$[i];\n    root = ancestor === window ? window : ancestor.getRootNode();\n\n    if (root !== lastRoot) {\n      rootIdx = refNodePath.indexOf(root);\n      lastRoot = root;\n    }\n\n    if (!utils_isShadyRoot(root) || rootIdx > -1) {\n      return ancestor;\n    }\n  }\n}\n\nvar eventMixin = {\n  /**\n   * @this {Event}\n   */\n  get composed() {\n    if (this.__composed === undefined) {\n      // if there's an original `composed` getter on the Event prototype, use that\n      if (composedGetter) {\n        // TODO(web-padawan): see https://github.com/webcomponents/shadydom/issues/275\n        this.__composed = this.type === 'focusin' || this.type === 'focusout' || composedGetter(this); // If the event is trusted, or `isTrusted` is not supported, check the list of always composed events\n      } else if (this.isTrusted !== false) {\n        this.__composed = alwaysComposed[this.type];\n      }\n    }\n\n    return this.__composed || false;\n  },\n\n  /**\n   * @this {Event}\n   */\n  composedPath: function composedPath() {\n    if (!this.__composedPath) {\n      this.__composedPath = pathComposer(this['__target'], this.composed);\n    }\n\n    return this.__composedPath;\n  },\n\n  /**\n   * @this {Event}\n   */\n  get target() {\n    return retarget(this.currentTarget || this['__previousCurrentTarget'], this.composedPath());\n  },\n\n  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n\n  /**\n   * @this {Event}\n   */\n  get relatedTarget() {\n    if (!this.__relatedTarget) {\n      return null;\n    }\n\n    if (!this.__relatedTargetComposedPath) {\n      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\n    } // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n\n\n    return retarget(this.currentTarget || this['__previousCurrentTarget'], this.__relatedTargetComposedPath);\n  },\n\n  /**\n   * @this {Event}\n   */\n  stopPropagation: function stopPropagation() {\n    Event.prototype.stopPropagation.call(this);\n    this.__propagationStopped = true;\n  },\n\n  /**\n   * @this {Event}\n   */\n  stopImmediatePropagation: function stopImmediatePropagation() {\n    Event.prototype.stopImmediatePropagation.call(this);\n    this.__immediatePropagationStopped = true;\n    this.__propagationStopped = true;\n  }\n};\n\nfunction mixinComposedFlag(Base) {\n  // NOTE: avoiding use of `class` here so that transpiled output does not\n  // try to do `Base.call` with a dom construtor.\n  var klazz = function klazz(type, options) {\n    var event = new Base(type, options);\n    event.__composed = options && Boolean(options['composed']);\n    return event;\n  }; // put constructor properties on subclass\n\n\n  mixin(klazz, Base);\n  klazz.prototype = Base.prototype;\n  return klazz;\n}\n\nvar nonBubblingEventsToRetarget = {\n  'focus': true,\n  'blur': true\n};\n/**\n * Check if the event has been retargeted by comparing original `target`, and calculated `target`\n * @param {Event} event\n * @return {boolean} True if the original target and calculated target are the same\n */\n\nfunction hasRetargeted(event) {\n  return event['__target'] !== event.target || event.__relatedTarget !== event.relatedTarget;\n}\n/**\n *\n * @param {Event} event\n * @param {Node} node\n * @param {string} phase\n */\n\n\nfunction fireHandlers(event, node, phase) {\n  var hs = node.__handlers && node.__handlers[event.type] && node.__handlers[event.type][phase];\n\n  if (hs) {\n    for (var i = 0, fn; fn = hs[i]; i++) {\n      if (hasRetargeted(event) && event.target === event.relatedTarget) {\n        return;\n      }\n\n      fn.call(node, event);\n\n      if (event.__immediatePropagationStopped) {\n        return;\n      }\n    }\n  }\n}\n\nfunction retargetNonBubblingEvent(e) {\n  var path = e.composedPath();\n  var node; // override `currentTarget` to let patched `target` calculate correctly\n\n  Object.defineProperty(e, 'currentTarget', {\n    get: function get() {\n      return node;\n    },\n    configurable: true\n  });\n\n  for (var i = path.length - 1; i >= 0; i--) {\n    node = path[i]; // capture phase fires all capture handlers\n\n    fireHandlers(e, node, 'capture');\n\n    if (e.__propagationStopped) {\n      return;\n    }\n  } // set the event phase to `AT_TARGET` as in spec\n\n\n  Object.defineProperty(e, 'eventPhase', {\n    get: function get() {\n      return Event.AT_TARGET;\n    }\n  }); // the event only needs to be fired when owner roots change when iterating the event path\n  // keep track of the last seen owner root\n\n  var lastFiredRoot;\n\n  for (var _i = 0; _i < path.length; _i++) {\n    node = path[_i];\n    var nodeData = shadyDataForNode(node);\n    var root = nodeData && nodeData.root;\n\n    if (_i === 0 || root && root === lastFiredRoot) {\n      fireHandlers(e, node, 'bubble'); // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway\n\n      if (node !== window) {\n        lastFiredRoot = node.getRootNode();\n      }\n\n      if (e.__propagationStopped) {\n        return;\n      }\n    }\n  }\n}\n\nfunction listenerSettingsEqual(savedListener, node, type, capture, once, passive) {\n  var savedNode = savedListener.node,\n      savedType = savedListener.type,\n      savedCapture = savedListener.capture,\n      savedOnce = savedListener.once,\n      savedPassive = savedListener.passive;\n  return node === savedNode && type === savedType && capture === savedCapture && once === savedOnce && passive === savedPassive;\n}\n\nfunction findListener(wrappers, node, type, capture, once, passive) {\n  for (var i = 0; i < wrappers.length; i++) {\n    if (listenerSettingsEqual(wrappers[i], node, type, capture, once, passive)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * Firefox can throw on accessing eventWrappers inside of `removeEventListener` during a selenium run\n * Try/Catch accessing eventWrappers to work around\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1353074\n */\n\nfunction getEventWrappers(eventLike) {\n  var wrappers = null;\n\n  try {\n    wrappers = eventLike[eventWrappersName];\n  } catch (e) {} // eslint-disable-line no-empty\n\n\n  return wrappers;\n}\n/**\n * @this {Event}\n */\n\n\nfunction patch_events_addEventListener(type, fnOrObj, optionsOrCapture) {\n  if (!fnOrObj) {\n    return;\n  }\n\n  var handlerType = _typeof(fnOrObj); // bail if `fnOrObj` is not a function, not an object\n\n\n  if (handlerType !== 'function' && handlerType !== 'object') {\n    return;\n  } // bail if `fnOrObj` is an object without a `handleEvent` method\n\n\n  if (handlerType === 'object' && (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {\n    return;\n  }\n\n  var ael = this instanceof Window ? windowAddEventListener : addEventListener;\n\n  if (unpatchedEvents[type]) {\n    return ael.call(this, type, fnOrObj, optionsOrCapture);\n  } // The callback `fn` might be used for multiple nodes/events. Since we generate\n  // a wrapper function, we need to keep track of it when we remove the listener.\n  // It's more efficient to store the node/type/options information as Array in\n  // `fn` itself rather than the node (we assume that the same callback is used\n  // for few nodes at most, whereas a node will likely have many event listeners).\n  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\n\n  var capture, once, passive;\n\n  if (optionsOrCapture && _typeof(optionsOrCapture) === 'object') {\n    capture = Boolean(optionsOrCapture.capture);\n    once = Boolean(optionsOrCapture.once);\n    passive = Boolean(optionsOrCapture.passive);\n  } else {\n    capture = Boolean(optionsOrCapture);\n    once = false;\n    passive = false;\n  } // hack to let ShadyRoots have event listeners\n  // event listener will be on host, but `currentTarget`\n  // will be set to shadyroot for event listener\n\n\n  var target = optionsOrCapture && optionsOrCapture.__shadyTarget || this;\n  var wrappers = fnOrObj[eventWrappersName];\n\n  if (wrappers) {\n    // Stop if the wrapper function has already been created.\n    if (findListener(wrappers, target, type, capture, once, passive) > -1) {\n      return;\n    }\n  } else {\n    fnOrObj[eventWrappersName] = [];\n  }\n  /**\n   * @this {HTMLElement}\n   * @param {Event} e\n   */\n\n\n  var wrapperFn = function wrapperFn(e) {\n    // Support `once` option.\n    if (once) {\n      this.removeEventListener(type, fnOrObj, optionsOrCapture);\n    }\n\n    if (!e['__target']) {\n      patchEvent(e);\n    }\n\n    var lastCurrentTargetDesc;\n\n    if (target !== this) {\n      // replace `currentTarget` to make `target` and `relatedTarget` correct for inside the shadowroot\n      lastCurrentTargetDesc = Object.getOwnPropertyDescriptor(e, 'currentTarget');\n      Object.defineProperty(e, 'currentTarget', {\n        get: function get() {\n          return target;\n        },\n        configurable: true\n      });\n    }\n\n    e['__previousCurrentTarget'] = e['currentTarget']; // Always check if a shadowRoot is in the current event path.\n    // If it is not, the event was generated on either the host of the shadowRoot\n    // or a children of the host.\n\n    if (utils_isShadyRoot(target) && e.composedPath().indexOf(target) == -1) {\n      return;\n    } // There are two critera that should stop events from firing on this node\n    // 1. the event is not composed and the current node is not in the same root as the target\n    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n\n\n    if (e.composed || e.composedPath().indexOf(target) > -1) {\n      if (hasRetargeted(e) && e.target === e.relatedTarget) {\n        if (e.eventPhase === Event.BUBBLING_PHASE) {\n          e.stopImmediatePropagation();\n        }\n\n        return;\n      } // prevent non-bubbling events from triggering bubbling handlers on shadowroot, but only if not in capture phase\n\n\n      if (e.eventPhase !== Event.CAPTURING_PHASE && !e.bubbles && e.target !== target && !(target instanceof Window)) {\n        return;\n      }\n\n      var ret = handlerType === 'function' ? fnOrObj.call(target, e) : fnOrObj.handleEvent && fnOrObj.handleEvent(e);\n\n      if (target !== this) {\n        // replace the \"correct\" `currentTarget`\n        if (lastCurrentTargetDesc) {\n          Object.defineProperty(e, 'currentTarget', lastCurrentTargetDesc);\n          lastCurrentTargetDesc = null;\n        } else {\n          delete e['currentTarget'];\n        }\n      }\n\n      return ret;\n    }\n  }; // Store the wrapper information.\n\n\n  fnOrObj[eventWrappersName].push({\n    // note: use target here which is either a shadowRoot\n    // (when the host element is proxy'ing the event) or this element\n    node: target,\n    type: type,\n    capture: capture,\n    once: once,\n    passive: passive,\n    wrapperFn: wrapperFn\n  });\n\n  if (nonBubblingEventsToRetarget[type]) {\n    this.__handlers = this.__handlers || {};\n    this.__handlers[type] = this.__handlers[type] || {\n      'capture': [],\n      'bubble': []\n    };\n\n    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n  } else {\n    ael.call(this, type, wrapperFn, optionsOrCapture);\n  }\n}\n/**\n * @this {Event}\n */\n\nfunction patch_events_removeEventListener(type, fnOrObj, optionsOrCapture) {\n  if (!fnOrObj) {\n    return;\n  }\n\n  var rel = this instanceof Window ? windowRemoveEventListener : removeEventListener;\n\n  if (unpatchedEvents[type]) {\n    return rel.call(this, type, fnOrObj, optionsOrCapture);\n  } // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n\n\n  var capture, once, passive;\n\n  if (optionsOrCapture && _typeof(optionsOrCapture) === 'object') {\n    capture = Boolean(optionsOrCapture.capture);\n    once = Boolean(optionsOrCapture.once);\n    passive = Boolean(optionsOrCapture.passive);\n  } else {\n    capture = Boolean(optionsOrCapture);\n    once = false;\n    passive = false;\n  }\n\n  var target = optionsOrCapture && optionsOrCapture.__shadyTarget || this; // Search the wrapped function.\n\n  var wrapperFn = undefined;\n  var wrappers = getEventWrappers(fnOrObj);\n\n  if (wrappers) {\n    var idx = findListener(wrappers, target, type, capture, once, passive);\n\n    if (idx > -1) {\n      wrapperFn = wrappers.splice(idx, 1)[0].wrapperFn; // Cleanup.\n\n      if (!wrappers.length) {\n        fnOrObj[eventWrappersName] = undefined;\n      }\n    }\n  }\n\n  rel.call(this, type, wrapperFn || fnOrObj, optionsOrCapture);\n\n  if (wrapperFn && nonBubblingEventsToRetarget[type] && this.__handlers && this.__handlers[type]) {\n    var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n\n    var _idx = arr.indexOf(wrapperFn);\n\n    if (_idx > -1) {\n      arr.splice(_idx, 1);\n    }\n  }\n}\n\nfunction activateFocusEventOverrides() {\n  for (var ev in nonBubblingEventsToRetarget) {\n    window.addEventListener(ev, function (e) {\n      if (!e['__target']) {\n        patchEvent(e);\n        retargetNonBubblingEvent(e);\n      }\n    }, true);\n  }\n}\n\nfunction patchEvent(event) {\n  event['__target'] = event.target;\n  event.__relatedTarget = event.relatedTarget; // patch event prototype if we can\n\n  if (settings.hasDescriptors) {\n    patchPrototype(event, eventMixin); // and fallback to patching instance\n  } else {\n    extend(event, eventMixin);\n  }\n}\n\nvar PatchedEvent = mixinComposedFlag(window.Event);\nvar PatchedCustomEvent = mixinComposedFlag(window.CustomEvent);\nvar PatchedMouseEvent = mixinComposedFlag(window.MouseEvent);\nfunction patchEvents() {\n  window.Event = PatchedEvent;\n  window.CustomEvent = PatchedCustomEvent;\n  window.MouseEvent = PatchedMouseEvent;\n  activateFocusEventOverrides(); // Fix up `Element.prototype.click()` if `isTrusted` is supported, but `composed` isn't\n\n  if (!composedGetter && Object.getOwnPropertyDescriptor(Event.prototype, 'isTrusted')) {\n    /** @this {Element} */\n    var composedClickFn = function composedClickFn() {\n      var ev = new MouseEvent('click', {\n        bubbles: true,\n        cancelable: true,\n        composed: true\n      });\n      this.dispatchEvent(ev);\n    };\n\n    if (Element.prototype.click) {\n      Element.prototype.click = composedClickFn;\n    } else if (HTMLElement.prototype.click) {\n      HTMLElement.prototype.click = composedClickFn;\n    }\n  }\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/array-splice.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nfunction newSplice(index, removed, addedCount) {\n  return {\n    index: index,\n    removed: removed,\n    addedCount: addedCount\n  };\n}\n\nvar EDIT_LEAVE = 0;\nvar EDIT_UPDATE = 1;\nvar EDIT_ADD = 2;\nvar EDIT_DELETE = 3; // Note: This function is *based* on the computation of the Levenshtein\n// \"edit\" distance. The one change is that \"updates\" are treated as two\n// edits - not one. With Array splices, an update is really a delete\n// followed by an add. By retaining this, we optimize for \"keeping\" the\n// maximum array items in the original array. For example:\n//\n//   'xxxx123' -> '123yyyy'\n//\n// With 1-edit updates, the shortest path would be just to update all seven\n// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n// leaves the substring '123' intact.\n\nfunction calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  // \"Deletion\" columns\n  var rowCount = oldEnd - oldStart + 1;\n  var columnCount = currentEnd - currentStart + 1;\n  var distances = new Array(rowCount); // \"Addition\" rows. Initialize null column.\n\n  for (var i = 0; i < rowCount; i++) {\n    distances[i] = new Array(columnCount);\n    distances[i][0] = i;\n  } // Initialize null row\n\n\n  for (var j = 0; j < columnCount; j++) {\n    distances[0][j] = j;\n  }\n\n  for (var _i = 1; _i < rowCount; _i++) {\n    for (var _j = 1; _j < columnCount; _j++) {\n      if (equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {\n        var north = distances[_i - 1][_j] + 1;\n        var west = distances[_i][_j - 1] + 1;\n        distances[_i][_j] = north < west ? north : west;\n      }\n    }\n  }\n\n  return distances;\n} // This starts at the final weight, and walks \"backward\" by finding\n// the minimum previous weight recursively until the origin of the weight\n// matrix.\n\n\nfunction spliceOperationsFromEditDistances(distances) {\n  var i = distances.length - 1;\n  var j = distances[0].length - 1;\n  var current = distances[i][j];\n  var edits = [];\n\n  while (i > 0 || j > 0) {\n    if (i == 0) {\n      edits.push(EDIT_ADD);\n      j--;\n      continue;\n    }\n\n    if (j == 0) {\n      edits.push(EDIT_DELETE);\n      i--;\n      continue;\n    }\n\n    var northWest = distances[i - 1][j - 1];\n    var west = distances[i - 1][j];\n    var north = distances[i][j - 1];\n    var min = void 0;\n    if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;\n\n    if (min == northWest) {\n      if (northWest == current) {\n        edits.push(EDIT_LEAVE);\n      } else {\n        edits.push(EDIT_UPDATE);\n        current = northWest;\n      }\n\n      i--;\n      j--;\n    } else if (min == west) {\n      edits.push(EDIT_DELETE);\n      i--;\n      current = west;\n    } else {\n      edits.push(EDIT_ADD);\n      j--;\n      current = north;\n    }\n  }\n\n  edits.reverse();\n  return edits;\n}\n/**\n * Splice Projection functions:\n *\n * A splice map is a representation of how a previous array of items\n * was transformed into a new array of items. Conceptually it is a list of\n * tuples of\n *\n *   <index, removed, addedCount>\n *\n * which are kept in ascending index order of. The tuple represents that at\n * the |index|, |removed| sequence of items were removed, and counting forward\n * from |index|, |addedCount| items were added.\n */\n\n/**\n * Lacking individual splice mutation information, the minimal set of\n * splices can be synthesized given the previous state and final state of an\n * array. The basic approach is to calculate the edit distance matrix and\n * choose the shortest path through it.\n *\n * Complexity: O(l * p)\n *   l: The length of the current array\n *   p: The length of the old array\n */\n\n\nfunction calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {\n  var prefixCount = 0;\n  var suffixCount = 0;\n  var splice;\n  var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n  if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);\n  if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);\n  currentStart += prefixCount;\n  oldStart += prefixCount;\n  currentEnd -= suffixCount;\n  oldEnd -= suffixCount;\n  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];\n\n  if (currentStart == currentEnd) {\n    splice = newSplice(currentStart, [], 0);\n\n    while (oldStart < oldEnd) {\n      splice.removed.push(old[oldStart++]);\n    }\n\n    return [splice];\n  } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];\n\n  var ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\n  splice = undefined;\n  var splices = [];\n  var index = currentStart;\n  var oldIndex = oldStart;\n\n  for (var i = 0; i < ops.length; i++) {\n    switch (ops[i]) {\n      case EDIT_LEAVE:\n        if (splice) {\n          splices.push(splice);\n          splice = undefined;\n        }\n\n        index++;\n        oldIndex++;\n        break;\n\n      case EDIT_UPDATE:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.addedCount++;\n        index++;\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n\n      case EDIT_ADD:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.addedCount++;\n        index++;\n        break;\n\n      case EDIT_DELETE:\n        if (!splice) splice = newSplice(index, [], 0);\n        splice.removed.push(old[oldIndex]);\n        oldIndex++;\n        break;\n    }\n  }\n\n  if (splice) {\n    splices.push(splice);\n  }\n\n  return splices;\n}\n\nfunction sharedPrefix(current, old, searchLength) {\n  for (var i = 0; i < searchLength; i++) {\n    if (!equals(current[i], old[i])) return i;\n  }\n\n  return searchLength;\n}\n\nfunction sharedSuffix(current, old, searchLength) {\n  var index1 = current.length;\n  var index2 = old.length;\n  var count = 0;\n\n  while (count < searchLength && equals(current[--index1], old[--index2])) {\n    count++;\n  }\n\n  return count;\n}\n\nfunction equals(currentValue, previousValue) {\n  return currentValue === previousValue;\n}\n\nfunction calculateSplices(current, previous) {\n  return calcSplices(current, 0, current.length, previous, 0, previous.length);\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/attach-shadow.js\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction attach_shadow_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction attach_shadow_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction attach_shadow_createClass(Constructor, protoProps, staticProps) { if (protoProps) attach_shadow_defineProperties(Constructor.prototype, protoProps); if (staticProps) attach_shadow_defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n\nvar attach_shadow_parentNode = accessors.parentNode,\n    attach_shadow_childNodes = accessors.childNodes; // Do not export this object. It must be passed as the first argument to the\n// ShadyRoot constructor in `attachShadow` to prevent the constructor from\n// throwing. This prevents the user from being able to manually construct a\n// ShadyRoot (i.e. `new ShadowRoot()`).\n\nvar ShadyRootConstructionToken = {};\nvar CATCHALL_NAME = '__catchall';\nvar SHADYROOT_NAME = 'ShadyRoot';\nvar MODE_CLOSED = 'closed';\nvar isRendering = settings['deferConnectionCallbacks'] && document.readyState === 'loading';\nvar rootRendered;\n\nfunction ancestorList(node) {\n  var ancestors = [];\n\n  do {\n    ancestors.unshift(node);\n  } while (node = node.parentNode);\n\n  return ancestors;\n}\n/**\n * @extends {ShadowRoot}\n */\n\n\nvar attach_shadow_ShadyRoot =\n/*#__PURE__*/\nfunction () {\n  function ShadyRoot(token, host, options) {\n    attach_shadow_classCallCheck(this, ShadyRoot);\n\n    if (token !== ShadyRootConstructionToken) {\n      throw new TypeError('Illegal constructor');\n    } // NOTE: set a fake local name so this element can be\n    // distinguished from a DocumentFragment when patching.\n    // FF doesn't allow this to be `localName`\n\n\n    this._localName = SHADYROOT_NAME; // root <=> host\n\n    this.host = host;\n    this._mode = options && options.mode;\n    recordChildNodes(host);\n    var hostData = ensureShadyDataForNode(host);\n    hostData.root = this;\n    hostData.publicRoot = this._mode !== MODE_CLOSED ? this : null; // setup root\n\n    var rootData = ensureShadyDataForNode(this);\n    rootData.firstChild = rootData.lastChild = rootData.parentNode = rootData.nextSibling = rootData.previousSibling = null;\n    rootData.childNodes = []; // state flags\n\n    this._renderPending = false;\n    this._hasRendered = false; // marsalled lazily\n\n    this._slotList = null;\n    /** @type {Object<string, Array<HTMLSlotElement>>} */\n\n    this._slotMap = null;\n    this._pendingSlots = null;\n    this._initialChildren = null;\n\n    this._asyncRender();\n  } // async render\n\n\n  attach_shadow_createClass(ShadyRoot, [{\n    key: \"_asyncRender\",\n    value: function _asyncRender() {\n      var _this = this;\n\n      if (!this._renderPending) {\n        this._renderPending = true;\n        enqueue(function () {\n          return _this._render();\n        });\n      }\n    } // returns the oldest renderPending ancestor root.\n\n  }, {\n    key: \"_getRenderRoot\",\n    value: function _getRenderRoot() {\n      var renderRoot;\n      var root = this;\n\n      while (root) {\n        if (root._renderPending) {\n          renderRoot = root;\n        }\n\n        root = root._rendererForHost();\n      }\n\n      return renderRoot;\n    } // Returns the shadyRoot `this.host` if `this.host`\n    // has children that require distribution.\n\n  }, {\n    key: \"_rendererForHost\",\n    value: function _rendererForHost() {\n      var root = this.host.getRootNode();\n\n      if (utils_isShadyRoot(root)) {\n        var c$ = this.host.childNodes;\n\n        for (var i = 0, c; i < c$.length; i++) {\n          c = c$[i];\n\n          if (this._isInsertionPoint(c)) {\n            return root;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      var root = this._getRenderRoot();\n\n      if (root) {\n        root['_renderRoot']();\n      }\n    } // NOTE: avoid renaming to ease testability.\n\n  }, {\n    key: '_renderRoot',\n    value: function _renderRoot() {\n      // track rendering state.\n      var wasRendering = isRendering;\n      isRendering = true;\n      this._renderPending = false;\n\n      if (this._slotList) {\n        this._distribute();\n\n        this._compose();\n      } // on initial render remove any undistributed children.\n\n\n      if (!this._hasRendered) {\n        var c$ = this.host.childNodes;\n\n        for (var i = 0, l = c$.length; i < l; i++) {\n          var child = c$[i];\n          var data = shadyDataForNode(child);\n\n          if (attach_shadow_parentNode(child) === this.host && (child.localName === 'slot' || !data.assignedSlot)) {\n            native_methods_removeChild.call(this.host, child);\n          }\n        }\n      }\n\n      this._hasRendered = true;\n      isRendering = wasRendering;\n\n      if (rootRendered) {\n        rootRendered();\n      }\n    }\n  }, {\n    key: \"_distribute\",\n    value: function _distribute() {\n      this._validateSlots(); // capture # of previously assigned nodes to help determine if dirty.\n\n\n      for (var i = 0, slot; i < this._slotList.length; i++) {\n        slot = this._slotList[i];\n\n        this._clearSlotAssignedNodes(slot);\n      } // distribute host children.\n\n\n      for (var n = this.host.firstChild; n; n = n.nextSibling) {\n        this._distributeNodeToSlot(n);\n      } // fallback content, slotchange, and dirty roots\n\n\n      for (var _i = 0; _i < this._slotList.length; _i++) {\n        var _slot = this._slotList[_i];\n        var slotData = shadyDataForNode(_slot); // distribute fallback content\n\n        if (!slotData.assignedNodes.length) {\n          for (var _n = _slot.firstChild; _n; _n = _n.nextSibling) {\n            this._distributeNodeToSlot(_n, _slot);\n          }\n        }\n\n        var slotParentData = shadyDataForNode(_slot.parentNode);\n        var slotParentRoot = slotParentData && slotParentData.root;\n\n        if (slotParentRoot && slotParentRoot._hasInsertionPoint()) {\n          slotParentRoot['_renderRoot']();\n        }\n\n        this._addAssignedToFlattenedNodes(slotData.flattenedNodes, slotData.assignedNodes);\n\n        var prevAssignedNodes = slotData._previouslyAssignedNodes;\n\n        if (prevAssignedNodes) {\n          for (var _i2 = 0; _i2 < prevAssignedNodes.length; _i2++) {\n            shadyDataForNode(prevAssignedNodes[_i2])._prevAssignedSlot = null;\n          }\n\n          slotData._previouslyAssignedNodes = null; // dirty if previously less assigned nodes than previously assigned.\n\n          if (prevAssignedNodes.length > slotData.assignedNodes.length) {\n            slotData.dirty = true;\n          }\n        }\n        /* Note: A slot is marked dirty whenever a node is newly assigned to it\n        or a node is assigned to a different slot (done in `_distributeNodeToSlot`)\n        or if the number of nodes assigned to the slot has decreased (done above);\n        */\n\n\n        if (slotData.dirty) {\n          slotData.dirty = false;\n\n          this._fireSlotChange(_slot);\n        }\n      }\n    }\n    /**\n     * Distributes given `node` to the appropriate slot based on its `slot`\n     * attribute. If `forcedSlot` is given, then the node is distributed to the\n     * `forcedSlot`.\n     * Note: slot to which the node is assigned will be marked dirty for firing\n     * `slotchange`.\n     * @param {Node} node\n     * @param {Node=} forcedSlot\n     *\n     */\n\n  }, {\n    key: \"_distributeNodeToSlot\",\n    value: function _distributeNodeToSlot(node, forcedSlot) {\n      var nodeData = ensureShadyDataForNode(node);\n      var oldSlot = nodeData._prevAssignedSlot;\n      nodeData._prevAssignedSlot = null;\n      var slot = forcedSlot;\n\n      if (!slot) {\n        var name = node.slot || CATCHALL_NAME;\n        var list = this._slotMap[name];\n        slot = list && list[0];\n      }\n\n      if (slot) {\n        var slotData = ensureShadyDataForNode(slot);\n        slotData.assignedNodes.push(node);\n        nodeData.assignedSlot = slot;\n      } else {\n        nodeData.assignedSlot = undefined;\n      }\n\n      if (oldSlot !== nodeData.assignedSlot) {\n        if (nodeData.assignedSlot) {\n          ensureShadyDataForNode(nodeData.assignedSlot).dirty = true;\n        }\n      }\n    }\n    /**\n     * Clears the assignedNodes tracking data for a given `slot`. Note, the current\n     * assigned node data is tracked (via _previouslyAssignedNodes and\n     * _prevAssignedSlot) to see if `slotchange` should fire. This data may be out\n     *  of date at this time because the assigned nodes may have already been\n     * distributed to another root. This is ok since this data is only used to\n     * track changes.\n     * @param {HTMLSlotElement} slot\n     */\n\n  }, {\n    key: \"_clearSlotAssignedNodes\",\n    value: function _clearSlotAssignedNodes(slot) {\n      var slotData = shadyDataForNode(slot);\n      var n$ = slotData.assignedNodes;\n      slotData.assignedNodes = [];\n      slotData.flattenedNodes = [];\n      slotData._previouslyAssignedNodes = n$;\n\n      if (n$) {\n        for (var i = 0; i < n$.length; i++) {\n          var n = shadyDataForNode(n$[i]);\n          n._prevAssignedSlot = n.assignedSlot; // only clear if it was previously set to this slot;\n          // this helps ensure that if the node has otherwise been distributed\n          // ignore it.\n\n          if (n.assignedSlot === slot) {\n            n.assignedSlot = null;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_addAssignedToFlattenedNodes\",\n    value: function _addAssignedToFlattenedNodes(flattened, assigned) {\n      for (var i = 0, n; i < assigned.length && (n = assigned[i]); i++) {\n        if (n.localName == 'slot') {\n          var nestedAssigned = shadyDataForNode(n).assignedNodes;\n\n          if (nestedAssigned && nestedAssigned.length) {\n            this._addAssignedToFlattenedNodes(flattened, nestedAssigned);\n          }\n        } else {\n          flattened.push(assigned[i]);\n        }\n      }\n    }\n  }, {\n    key: \"_fireSlotChange\",\n    value: function _fireSlotChange(slot) {\n      // NOTE: cannot bubble correctly here so not setting bubbles: true\n      // Safari tech preview does not bubble but chrome does\n      // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n      native_methods_dispatchEvent.call(slot, new Event('slotchange'));\n      var slotData = shadyDataForNode(slot);\n\n      if (slotData.assignedSlot) {\n        this._fireSlotChange(slotData.assignedSlot);\n      }\n    } // Reify dom such that it is at its correct rendering position\n    // based on logical distribution.\n    // NOTE: here we only compose parents of <slot> elements and not the\n    // shadowRoot into the host. The latter is performend via a fast path\n    // in the `logical-mutation`.insertBefore.\n\n  }, {\n    key: \"_compose\",\n    value: function _compose() {\n      var slots = this._slotList;\n      var composeList = [];\n\n      for (var i = 0; i < slots.length; i++) {\n        var parent = slots[i].parentNode;\n        /* compose node only if:\n          (1) parent does not have a shadowRoot since shadowRoot has already\n          composed into the host\n          (2) we're not already composing it\n          [consider (n^2) but rare better than Set]\n        */\n\n        var parentData = shadyDataForNode(parent);\n\n        if (!(parentData && parentData.root) && composeList.indexOf(parent) < 0) {\n          composeList.push(parent);\n        }\n      }\n\n      for (var _i3 = 0; _i3 < composeList.length; _i3++) {\n        var node = composeList[_i3];\n        var targetNode = node === this ? this.host : node;\n\n        this._updateChildNodes(targetNode, this._composeNode(node));\n      }\n    } // Returns the list of nodes which should be rendered inside `node`.\n\n  }, {\n    key: \"_composeNode\",\n    value: function _composeNode(node) {\n      var children = [];\n      var c$ = node.childNodes;\n\n      for (var i = 0; i < c$.length; i++) {\n        var child = c$[i]; // Note: if we see a slot here, the nodes are guaranteed to need to be\n        // composed here. This is because if there is redistribution, it has\n        // already been handled by this point.\n\n        if (this._isInsertionPoint(child)) {\n          var flattenedNodes = shadyDataForNode(child).flattenedNodes;\n\n          for (var j = 0; j < flattenedNodes.length; j++) {\n            var distributedNode = flattenedNodes[j];\n            children.push(distributedNode);\n          }\n        } else {\n          children.push(child);\n        }\n      }\n\n      return children;\n    }\n  }, {\n    key: \"_isInsertionPoint\",\n    value: function _isInsertionPoint(node) {\n      return node.localName == 'slot';\n    } // Ensures that the rendered node list inside `container` is `children`.\n\n  }, {\n    key: \"_updateChildNodes\",\n    value: function _updateChildNodes(container, children) {\n      var composed = attach_shadow_childNodes(container);\n      var splices = calculateSplices(children, composed); // process removals\n\n      for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {\n        for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {\n          // check if the node is still where we expect it is before trying\n          // to remove it; this can happen if we move a node and\n          // then schedule its previous host for distribution resulting in\n          // the node being removed here.\n          if (attach_shadow_parentNode(n) === container) {\n            native_methods_removeChild.call(container, n);\n          } // TODO(sorvell): avoid the need for splicing here.\n\n\n          composed.splice(s.index + d, 1);\n        }\n\n        d -= s.addedCount;\n      } // process adds\n\n\n      for (var _i4 = 0, _s, next; _i4 < splices.length && (_s = splices[_i4]); _i4++) {\n        //eslint-disable-line no-redeclare\n        next = composed[_s.index];\n\n        for (var _j = _s.index, _n2; _j < _s.index + _s.addedCount; _j++) {\n          _n2 = children[_j];\n          native_methods_insertBefore.call(container, _n2, next);\n          composed.splice(_j, 0, _n2);\n        }\n      }\n    }\n  }, {\n    key: \"_ensureSlotData\",\n    value: function _ensureSlotData() {\n      this._pendingSlots = this._pendingSlots || [];\n      this._slotList = this._slotList || [];\n      this._slotMap = this._slotMap || {};\n    }\n  }, {\n    key: \"_addSlots\",\n    value: function _addSlots(slots) {\n      var _this$_pendingSlots;\n\n      this._ensureSlotData();\n\n      (_this$_pendingSlots = this._pendingSlots).push.apply(_this$_pendingSlots, _toConsumableArray(slots));\n    }\n  }, {\n    key: \"_validateSlots\",\n    value: function _validateSlots() {\n      if (this._pendingSlots && this._pendingSlots.length) {\n        this._mapSlots(this._pendingSlots);\n\n        this._pendingSlots = [];\n      }\n    }\n    /**\n     * Adds the given slots. Slots are maintained in an dom-ordered list.\n     * In addition a map of name to slot is updated.\n     */\n\n  }, {\n    key: \"_mapSlots\",\n    value: function _mapSlots(slots) {\n      var slotNamesToSort;\n\n      for (var i = 0; i < slots.length; i++) {\n        var slot = slots[i]; // ensure insertionPoints's and their parents have logical dom info.\n        // save logical tree info\n        // a. for shadyRoot\n        // b. for insertion points (fallback)\n        // c. for parents of insertion points\n\n        recordChildNodes(slot);\n        recordChildNodes(slot.parentNode);\n\n        var name = this._nameForSlot(slot);\n\n        if (this._slotMap[name]) {\n          slotNamesToSort = slotNamesToSort || {};\n          slotNamesToSort[name] = true;\n\n          this._slotMap[name].push(slot);\n        } else {\n          this._slotMap[name] = [slot];\n        }\n\n        this._slotList.push(slot);\n      }\n\n      if (slotNamesToSort) {\n        for (var n in slotNamesToSort) {\n          this._slotMap[n] = this._sortSlots(this._slotMap[n]);\n        }\n      }\n    }\n  }, {\n    key: \"_nameForSlot\",\n    value: function _nameForSlot(slot) {\n      var name = slot['name'] || slot.getAttribute('name') || CATCHALL_NAME;\n      slot.__slotName = name;\n      return name;\n    }\n    /**\n     * Slots are kept in an ordered list. Slots with the same name\n     * are sorted here by tree order.\n     */\n\n  }, {\n    key: \"_sortSlots\",\n    value: function _sortSlots(slots) {\n      // NOTE: Cannot use `compareDocumentPosition` because it's not polyfilled,\n      // but the code here could be used to polyfill the preceeding/following info\n      // in `compareDocumentPosition`.\n      return slots.sort(function (a, b) {\n        var listA = ancestorList(a);\n        var listB = ancestorList(b);\n\n        for (var i = 0; i < listA.length; i++) {\n          var nA = listA[i];\n          var nB = listB[i];\n\n          if (nA !== nB) {\n            var c$ = Array.from(nA.parentNode.childNodes);\n            return c$.indexOf(nA) - c$.indexOf(nB);\n          }\n        }\n      });\n    }\n    /**\n     * Removes from tracked slot data any slots contained within `container` and\n     * then updates the tracked data (_slotList and _slotMap).\n     * Any removed slots also have their `assignedNodes` removed from comopsed dom.\n     */\n\n  }, {\n    key: \"_removeContainedSlots\",\n    value: function _removeContainedSlots(container) {\n      if (!this._slotList) {\n        return;\n      }\n\n      this._validateSlots();\n\n      var didRemove;\n      var map = this._slotMap;\n\n      for (var n in map) {\n        var slots = map[n];\n\n        for (var i = 0; i < slots.length; i++) {\n          var slot = slots[i];\n\n          if (utils_contains(container, slot)) {\n            slots.splice(i, 1);\n\n            var x = this._slotList.indexOf(slot);\n\n            if (x >= 0) {\n              this._slotList.splice(x, 1);\n            }\n\n            i--;\n\n            this._removeFlattenedNodes(slot);\n\n            didRemove = true;\n          }\n        }\n      }\n\n      return didRemove;\n    }\n  }, {\n    key: \"_updateSlotName\",\n    value: function _updateSlotName(slot) {\n      if (!this._slotList) {\n        return;\n      } // make sure slotMap is initialized with this slot\n\n\n      this._validateSlots();\n\n      var oldName = slot.__slotName;\n\n      var name = this._nameForSlot(slot);\n\n      if (name === oldName) {\n        return;\n      } // remove from existing tracking\n\n\n      var slots = this._slotMap[oldName];\n      var i = slots.indexOf(slot);\n\n      if (i >= 0) {\n        slots.splice(i, 1);\n      } // add to new location and sort if nedessary\n\n\n      var list = this._slotMap[name] || (this._slotMap[name] = []);\n      list.push(slot);\n\n      if (list.length > 1) {\n        this._slotMap[name] = this._sortSlots(list);\n      }\n    }\n  }, {\n    key: \"_removeFlattenedNodes\",\n    value: function _removeFlattenedNodes(slot) {\n      var data = shadyDataForNode(slot);\n      var n$ = data.flattenedNodes;\n\n      if (n$) {\n        for (var i = 0; i < n$.length; i++) {\n          var node = n$[i];\n          var parent = attach_shadow_parentNode(node);\n\n          if (parent) {\n            native_methods_removeChild.call(parent, node);\n          }\n        }\n      }\n\n      data.flattenedNodes = [];\n      data.assignedNodes = [];\n    }\n  }, {\n    key: \"_hasInsertionPoint\",\n    value: function _hasInsertionPoint() {\n      this._validateSlots();\n\n      return Boolean(this._slotList && this._slotList.length);\n    }\n  }]);\n\n  return ShadyRoot;\n}();\n\n\n/**\n  Implements a pared down version of ShadowDOM's scoping, which is easy to\n  polyfill across browsers.\n*/\n\nfunction attach_shadow_attachShadow(host, options) {\n  if (!host) {\n    throw 'Must provide a host.';\n  }\n\n  if (!options) {\n    throw 'Not enough arguments.';\n  }\n\n  return new attach_shadow_ShadyRoot(ShadyRootConstructionToken, host, options);\n} // Mitigate connect/disconnect spam by wrapping custom element classes.\n\nif (window['customElements'] && settings.inUse) {\n  // process connect/disconnect after roots have rendered to avoid\n  // issues with reaction stack.\n  var connectMap = new Map();\n\n  rootRendered = function rootRendered() {\n    // allow elements to connect\n    var map = Array.from(connectMap);\n    connectMap.clear();\n\n    for (var _i5 = 0; _i5 < map.length; _i5++) {\n      var _map$_i = _slicedToArray(map[_i5], 2),\n          e = _map$_i[0],\n          value = _map$_i[1];\n\n      if (value) {\n        e.__shadydom_connectedCallback();\n      } else {\n        e.__shadydom_disconnectedCallback();\n      }\n    }\n  }; // Document is in loading state and flag is set (deferConnectionCallbacks)\n  // so process connection stack when `readystatechange` fires.\n\n\n  if (isRendering) {\n    document.addEventListener('readystatechange', function () {\n      isRendering = false;\n      rootRendered();\n    }, {\n      once: true\n    });\n  }\n  /*\n   * (1) elements can only be connected/disconnected if they are in the expected\n   * state.\n   * (2) never run connect/disconnect during rendering to avoid reaction stack issues.\n   */\n\n\n  var ManageConnect = function ManageConnect(base, connected, disconnected) {\n    var counter = 0;\n    var connectFlag = \"__isConnected\".concat(counter++);\n\n    if (connected || disconnected) {\n      base.prototype.connectedCallback = base.prototype.__shadydom_connectedCallback = function () {\n        // if rendering defer connected\n        // otherwise connect only if we haven't already\n        if (isRendering) {\n          connectMap.set(this, true);\n        } else if (!this[connectFlag]) {\n          this[connectFlag] = true;\n\n          if (connected) {\n            connected.call(this);\n          }\n        }\n      };\n\n      base.prototype.disconnectedCallback = base.prototype.__shadydom_disconnectedCallback = function () {\n        // if rendering, cancel a pending connection and queue disconnect,\n        // otherwise disconnect only if a connection has been allowed\n        if (isRendering) {\n          // This is necessary only because calling removeChild\n          // on a node that requires distribution leaves it in the DOM tree\n          // until distribution.\n          // NOTE: remember this is checking the patched isConnected to determine\n          // if the node is in the logical tree.\n          if (!this.isConnected) {\n            connectMap.set(this, false);\n          }\n        } else if (this[connectFlag]) {\n          this[connectFlag] = false;\n\n          if (disconnected) {\n            disconnected.call(this);\n          }\n        }\n      };\n    }\n\n    return base;\n  };\n\n  var define = window['customElements']['define']; // NOTE: Instead of patching customElements.define,\n  // re-define on the CustomElementRegistry.prototype.define\n  // for Safari 10 compatibility (it's flakey otherwise).\n\n  Object.defineProperty(window['CustomElementRegistry'].prototype, 'define', {\n    value: function value(name, constructor) {\n      var connected = constructor.prototype.connectedCallback;\n      var disconnected = constructor.prototype.disconnectedCallback;\n      define.call(window['customElements'], name, ManageConnect(constructor, connected, disconnected)); // unpatch connected/disconnected on class; custom elements tears this off\n      // so the patch is maintained, but if the user calls these methods for\n      // e.g. testing, they will be as expected.\n\n      constructor.prototype.connectedCallback = connected;\n      constructor.prototype.disconnectedCallback = disconnected;\n    }\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-builtins.js\nfunction patch_builtins_typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { patch_builtins_typeof = function _typeof(obj) { return typeof obj; }; } else { patch_builtins_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return patch_builtins_typeof(obj); }\n\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n\n\n\n\n\n\n\n\nfunction getAssignedSlot(node) {\n  renderRootNode(node);\n  var nodeData = shadyDataForNode(node);\n  return nodeData && nodeData.assignedSlot || null;\n}\n\nvar windowMixin = {\n  // NOTE: ensure these methods are bound to `window` so that `this` is correct\n  // when called directly from global context without a receiver; e.g.\n  // `addEventListener(...)`.\n  addEventListener: patch_events_addEventListener.bind(window),\n  removeEventListener: patch_events_removeEventListener.bind(window)\n};\nvar nodeMixin = {\n  addEventListener: patch_events_addEventListener,\n  removeEventListener: patch_events_removeEventListener,\n  appendChild: function appendChild(node) {\n    return logical_mutation_insertBefore(this, node);\n  },\n  insertBefore: function insertBefore(node, ref_node) {\n    return logical_mutation_insertBefore(this, node, ref_node);\n  },\n  removeChild: function removeChild(node) {\n    return logical_mutation_removeChild(this, node);\n  },\n\n  /**\n   * @this {Node}\n   */\n  replaceChild: function replaceChild(node, ref_node) {\n    logical_mutation_insertBefore(this, node, ref_node);\n    logical_mutation_removeChild(this, ref_node);\n    return node;\n  },\n\n  /**\n   * @this {Node}\n   */\n  cloneNode: function cloneNode(deep) {\n    return logical_mutation_cloneNode(this, deep);\n  },\n\n  /**\n   * @this {Node}\n   */\n  getRootNode: function getRootNode(options) {\n    return logical_mutation_getRootNode(this, options);\n  },\n  contains: function contains(node) {\n    return utils_contains(this, node);\n  },\n\n  /**\n   * @this {Node}\n   */\n  dispatchEvent: function dispatchEvent(event) {\n    flush();\n    return native_methods_dispatchEvent.call(this, event);\n  }\n}; // NOTE: we can do this regardless of the browser supporting native accessors\n// since this is always \"new\" in that case.\n\nObject.defineProperties(nodeMixin, IsConnectedAccessor); // NOTE: For some reason 'Text' redefines 'assignedSlot'\n\nvar textMixin = {\n  /**\n   * @this {Text}\n   */\n  get assignedSlot() {\n    return getAssignedSlot(this);\n  }\n\n};\nvar fragmentMixin = {\n  // TODO(sorvell): consider doing native QSA and filtering results.\n\n  /**\n   * @this {DocumentFragment}\n   */\n  querySelector: function querySelector(selector) {\n    // match selector and halt on first result.\n    var result = query(this, function (n) {\n      return matchesSelector(n, selector);\n    }, function (n) {\n      return Boolean(n);\n    })[0];\n    return result || null;\n  },\n\n  /**\n   * @this {DocumentFragment}\n   */\n  // TODO(sorvell): `useNative` option relies on native querySelectorAll and\n  // misses distributed nodes, see\n  // https://github.com/webcomponents/shadydom/pull/210#issuecomment-361435503\n  querySelectorAll: function querySelectorAll(selector, useNative) {\n    if (useNative) {\n      var o = Array.prototype.slice.call(native_methods_querySelectorAll.call(this, selector));\n      var root = this.getRootNode();\n      return o.filter(function (e) {\n        return e.getRootNode() == root;\n      });\n    }\n\n    return query(this, function (n) {\n      return matchesSelector(n, selector);\n    });\n  }\n};\nvar slotMixin = {\n  /**\n   * @this {HTMLSlotElement}\n   */\n  assignedNodes: function assignedNodes(options) {\n    if (this.localName === 'slot') {\n      renderRootNode(this);\n      var nodeData = shadyDataForNode(this);\n      return nodeData ? (options && options.flatten ? nodeData.flattenedNodes : nodeData.assignedNodes) || [] : [];\n    }\n  }\n};\nvar elementMixin = extendAll({\n  /**\n   * @this {HTMLElement}\n   */\n  setAttribute: function setAttribute(name, value) {\n    logical_mutation_setAttribute(this, name, value);\n  },\n\n  /**\n   * @this {HTMLElement}\n   */\n  removeAttribute: function removeAttribute(name) {\n    logical_mutation_removeAttribute(this, name);\n  },\n\n  /**\n   * @this {HTMLElement}\n   */\n  attachShadow: function attachShadow(options) {\n    return attach_shadow_attachShadow(this, options);\n  },\n\n  /**\n   * @this {HTMLElement}\n   */\n  get slot() {\n    return this.getAttribute('slot');\n  },\n\n  /**\n   * @this {HTMLElement}\n   */\n  set slot(value) {\n    logical_mutation_setAttribute(this, 'slot', value);\n  },\n\n  /**\n   * @this {HTMLElement}\n   */\n  get assignedSlot() {\n    return getAssignedSlot(this);\n  }\n\n}, fragmentMixin, slotMixin);\nObject.defineProperties(elementMixin, ShadowRootAccessor);\nvar documentMixin = extendAll({\n  /**\n   * @this {Document}\n   */\n  importNode: function importNode(node, deep) {\n    return logical_mutation_importNode(node, deep);\n  },\n\n  /**\n   * @this {Document}\n   */\n  getElementById: function getElementById(id) {\n    var result = query(this, function (n) {\n      return n.id == id;\n    }, function (n) {\n      return Boolean(n);\n    })[0];\n    return result || null;\n  }\n}, fragmentMixin);\nObject.defineProperties(documentMixin, {\n  '_activeElement': ActiveElementAccessor.activeElement\n});\nvar nativeBlur = HTMLElement.prototype.blur;\nvar htmlElementMixin = {\n  /**\n   * @this {HTMLElement}\n   */\n  blur: function blur() {\n    var nodeData = shadyDataForNode(this);\n    var root = nodeData && nodeData.root;\n    var shadowActive = root && root.activeElement;\n\n    if (shadowActive) {\n      shadowActive.blur();\n    } else {\n      nativeBlur.call(this);\n    }\n  }\n};\nvar _iteratorNormalCompletion = true;\nvar _didIteratorError = false;\nvar _iteratorError = undefined;\n\ntry {\n  var patch_builtins_loop = function _loop() {\n    var property = _step.value;\n\n    if (property.substring(0, 2) === 'on') {\n      Object.defineProperty(htmlElementMixin, property, {\n        /** @this {HTMLElement} */\n        set: function set(fn) {\n          var shadyData = ensureShadyDataForNode(this);\n          var eventName = property.substring(2);\n          shadyData.__onCallbackListeners[property] && this.removeEventListener(eventName, shadyData.__onCallbackListeners[property]);\n          this.addEventListener(eventName, fn, {});\n          shadyData.__onCallbackListeners[property] = fn;\n        },\n\n        /** @this {HTMLElement} */\n        get: function get() {\n          var shadyData = shadyDataForNode(this);\n          return shadyData && shadyData.__onCallbackListeners[property];\n        },\n        configurable: true\n      });\n    }\n  };\n\n  for (var _iterator = Object.getOwnPropertyNames(Document.prototype)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n    patch_builtins_loop();\n  }\n} catch (err) {\n  _didIteratorError = true;\n  _iteratorError = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion && _iterator.return != null) {\n      _iterator.return();\n    }\n  } finally {\n    if (_didIteratorError) {\n      throw _iteratorError;\n    }\n  }\n}\n\nvar shadowRootMixin = {\n  /**\n   * @this {ShadowRoot}\n   */\n  addEventListener: function addEventListener(type, fn, optionsOrCapture) {\n    if (patch_builtins_typeof(optionsOrCapture) !== 'object') {\n      optionsOrCapture = {\n        capture: Boolean(optionsOrCapture)\n      };\n    }\n\n    optionsOrCapture.__shadyTarget = this;\n    this.host.addEventListener(type, fn, optionsOrCapture);\n  },\n\n  /**\n   * @this {ShadowRoot}\n   */\n  removeEventListener: function removeEventListener(type, fn, optionsOrCapture) {\n    if (patch_builtins_typeof(optionsOrCapture) !== 'object') {\n      optionsOrCapture = {\n        capture: Boolean(optionsOrCapture)\n      };\n    }\n\n    optionsOrCapture.__shadyTarget = this;\n    this.host.removeEventListener(type, fn, optionsOrCapture);\n  },\n\n  /**\n   * @this {ShadowRoot}\n   */\n  getElementById: function getElementById(id) {\n    var result = query(this, function (n) {\n      return n.id == id;\n    }, function (n) {\n      return Boolean(n);\n    })[0];\n    return result || null;\n  }\n};\n\nfunction patchBuiltin(proto, obj) {\n  var n$ = Object.getOwnPropertyNames(obj);\n\n  for (var i = 0; i < n$.length; i++) {\n    var n = n$[i];\n    var d = Object.getOwnPropertyDescriptor(obj, n); // NOTE: we prefer writing directly here because some browsers\n    // have descriptors that are writable but not configurable (e.g.\n    // `appendChild` on older browsers)\n\n    if (d.value) {\n      proto[n] = d.value;\n    } else {\n      Object.defineProperty(proto, n, d);\n    }\n  }\n} // Apply patches to builtins (e.g. Element.prototype). Some of these patches\n// can be done unconditionally (mostly methods like\n// `Element.prototype.appendChild`) and some can only be done when the browser\n// has proper descriptors on the builtin prototype\n// (e.g. `Element.prototype.firstChild`)`. When descriptors are not available,\n// elements are individually patched when needed (see e.g.\n// `patchInside/OutsideElementAccessors` in `patch-accessors.js`).\n\n\nfunction patchBuiltins() {\n  var nativeHTMLElement = window['customElements'] && window['customElements']['nativeHTMLElement'] || HTMLElement; // These patches can always be done, for all supported browsers.\n\n  patchBuiltin(attach_shadow_ShadyRoot.prototype, shadowRootMixin);\n  patchBuiltin(window.Node.prototype, nodeMixin);\n  patchBuiltin(window.Window.prototype, windowMixin);\n  patchBuiltin(window.Text.prototype, textMixin);\n  patchBuiltin(window.DocumentFragment.prototype, fragmentMixin);\n  patchBuiltin(window.Element.prototype, elementMixin);\n  patchBuiltin(window.Document.prototype, documentMixin);\n\n  if (window.HTMLSlotElement) {\n    patchBuiltin(window.HTMLSlotElement.prototype, slotMixin);\n  }\n\n  patchBuiltin(nativeHTMLElement.prototype, htmlElementMixin); // These patches can *only* be done\n  // on browsers that have proper property descriptors on builtin prototypes.\n  // This includes: IE11, Edge, Chrome >= 4?; Safari >= 10, Firefox\n  // On older browsers (Chrome <= 4?, Safari 9), a per element patching\n  // strategy is used for patching accessors.\n\n  if (settings.hasDescriptors) {\n    patchAccessors(window.Node.prototype);\n    patchAccessors(window.Text.prototype);\n    patchAccessors(window.DocumentFragment.prototype);\n    patchAccessors(window.Element.prototype);\n    patchAccessors(nativeHTMLElement.prototype);\n    patchAccessors(window.Document.prototype);\n\n    if (window.HTMLSlotElement) {\n      patchAccessors(window.HTMLSlotElement.prototype);\n    }\n  }\n\n  patchShadowRootAccessors(attach_shadow_ShadyRoot.prototype);\n}\n// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/shadydom.js\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Patches elements that interacts with ShadyDOM\n * such that tree traversal and mutation apis act like they would under\n * ShadowDOM.\n *\n * This import enables seemless interaction with ShadyDOM powered\n * custom elements, enabling better interoperation with 3rd party code,\n * libraries, and frameworks that use DOM tree manipulation apis.\n */\n\n\n\n\n\n\n\n\n\n\nif (settings.inUse) {\n  var ShadyDOM = {\n    // TODO(sorvell): remove when Polymer does not depend on this.\n    'inUse': settings.inUse,\n    // NOTE: old browsers without prototype accessors (very old Chrome\n    // and Safari) need manually patched accessors to properly set\n    // `innerHTML` and `textContent` when an element is:\n    // (1) inside a shadowRoot\n    // (2) does not have special (slot) children itself\n    // (3) and setting the property needs to provoke distribution (because\n    // a nested slot is added/removed)\n    'patch': function patch(node) {\n      patchInsideElementAccessors(node);\n      patchOutsideElementAccessors(node);\n      return node;\n    },\n    'isShadyRoot': utils_isShadyRoot,\n    'enqueue': enqueue,\n    'flush': flush,\n    'settings': settings,\n    'filterMutations': filterMutations,\n    'observeChildren': observe_changes_observeChildren,\n    'unobserveChildren': observe_changes_unobserveChildren,\n    'nativeMethods': native_methods_namespaceObject,\n    'nativeTree': accessors,\n    // Set to true to defer native custom elements connection until the\n    // document has fully parsed. This enables custom elements that create\n    // shadowRoots to be defined while the document is loading. Elements\n    // customized as they are created by the parser will successfully\n    // render with this flag on.\n    'deferConnectionCallbacks': settings['deferConnectionCallbacks'],\n    // Integration point with ShadyCSS to disable styling MutationObserver,\n    // as ShadyDOM will now handle dynamic scoping.\n    'handlesDynamicScoping': true\n  };\n  window['ShadyDOM'] = ShadyDOM; // Apply patches to events...\n\n  patchEvents(); // Apply patches to builtins (e.g. Element.prototype) where applicable.\n\n  patchBuiltins();\n  window.ShadowRoot = attach_shadow_ShadyRoot;\n}\n\n//# sourceURL=webpack:///./node_modules/@webcomponents/shadydom/src/shadydom.js_+_16_modules?");

/***/ })

}]);